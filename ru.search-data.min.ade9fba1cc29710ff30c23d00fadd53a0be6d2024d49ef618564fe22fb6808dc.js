'use strict';(function(){const indexCfg={split:/[^a-zа-яё0-9\w]/gi};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/avito-android/analytics/','title':"Analytics",'content':""});index.add({'id':1,'href':'/avito-android/analytics/analytics/','title':"Analytics",'content':"Analytics Для сбора данных используем собственные транспорты:\n Clickstream Statsd  Поверх транспорта есть готовые обертки под конкретные задачи:\n Performance аналитика  "});index.add({'id':2,'href':'/avito-android/checks/androidlint/','title':"Android Lint",'content':"Lint https://developer.android.com/studio/write/lint\nВ PR результаты отображаются во вкладках \u0026ldquo;\u0026lt;app name\u0026gt; lint\u0026rdquo;.\nНастройки Помимо стандартных настроек lint у нас есть:\n Проставляем общие lintOptions для всех модулей в рутовом build.gradle Рутовый lint.xml для задания исключений для всех модулей в репозитории Плагин для общего lint отчета по всем модулям: com.avito.android.lint-report  Как подавить ошибку? Используем стандартные возможности lint (Configure lint to suppress warnings):\n Проставить аннотацию @Suppress в коде, если это единичное ложное срабатывание Добавить исключение в lint.xml  Конкретного модуля (android library).\nИспользуем lintOptions.checkDependencies, поэтому может не примениться для приложения, которое подключает модуль. Приложения (android application) Всего репозитория. Отключит проверку во всех модулях.    Кастомные проверки Все кастомные проверки лежат в модуле lint-checks.\nКак написать свою проверку?  KotlinConf 2017 - Kotlin Static Analysis with Android Lint by Tor Norbye: video, presentation Sample project  Отлично покрываются тестами, но если нужна отладка, то используем общий подход - debugging\n"});index.add({'id':3,'href':'/avito-android/ide/templates/','title':"Android Studio templates",'content':"Android Studio templates Запустите install_templates.sh или скопируйте папку вручную из ./templates в $ANDROID_STUDIO_DIR/plugins/android/lib/templates/other\n"});index.add({'id':4,'href':'/avito-android/architectureguidelines/','title':"Architecture Guidelines",'content':"Architecture Guidelines В этом документе описаны общие соглашения по архитектуре проекта.\nLayers Используем разбиение на следующие сущности:\nRouter Берет на себя задачи навигации, взаимодействия с android. Часто интерфейс роутера реализует Activity/Fragment.\nView Это POJO. Причины существования в отдельном классе:\n Отделить детали работы с UI от жизненного цикла и прочего взаимодействия с android Ограничить возможности. View видит ограниченный интерфейс презентера и физически не может сделать ничего лишнего.  View пассивна. Должна отражать это в своем интерфейсе, который видно презентеру. View не знает про доменные объекты\nPresenter  Реализует презентационную логику - конвертацию доменных объектов в примитивы для UI Хранит состояние представления, необходимое для восстановления и работы View. Это не должны быть сырые данные, за них отвечает interactor. Избегает зависимости от Android.  Interactor  Скрывает детали загрузки данных Может кешировать загруженные доменные объекты Избегает зависимости от Android  Каждый слой должен иметь интефейс, отражающий указанные особенности. В целом стремимся к чистой архитектуре, чтобы улучшить тестируемость кода и уменьшить связанность.\nCases List/Adapter Для адаптера делаем свой маленький презентер, который берет на себя задачи репрезентации доменной модели.\n"});index.add({'id':5,'href':'/avito-android/architecture/','title':"Architectures",'content':""});index.add({'id':6,'href':'/avito-android/cd/artifacts/','title':"Artifacts",'content':"Артефакты сборки Где храним артефакты? Используем несколько хранилищ:\n Artifactory  feature-toggles.json api.json staging apk   QApps Play market/Play console  релизный aab релизный proguard mapping   Teamcity Android PR checks  Вкладка Artifacts у билда Все файлы pull request Живет ~ 1 месяц   Teamcity Android Release  Вкладка Artifacts у билда Все файлы релизной сборки Живет ~ 1 месяц    "});index.add({'id':7,'href':'/avito-android/assemble/','title':"Assembles",'content':""});index.add({'id':8,'href':'/avito-android/assemble/buildtypes/','title':"Build Types",'content':"Типы сборок Различаются по предназначению:\n debug - существует для максимально быстрой сборки, чтобы получить максимально быстрый фидбек на изменения в коде staging - для ручного тестирования, сборка проходит медленнее за счет минимизации, но без нее не получится отловить определенный тип багов release - для заливки в магазин      Релизная подпись Минимизация Обфускация Avito Settings Charles proxy     debug нет нет нет да да   staging да да нет да да   release да да да нет нет    Релизная подпись Подпись может влиять на настройки разных 3rd party API. Например карты google привязаны к определенной подписи, и без нее могут не показываться вовсе, если также не зарегистрирован API карт на debug ключ.\nПримеры других зависимостей: рекламные SDK, социальные сети.\nМинимизация Используется, чтобы уменьшить размер архива с приложением, выпилив оттуда неиспользуемый код. Правила по которым определяется что есть используемый код могут быть ошибочны, так что тестировать следует приложение после минимизации\nОбфускация Используется, чтобы запутать взломщиков, в общем случае не должно влиять на корректность кода.\nAvito Settings Дополнительное приложение с набором настроек для помощи в ручном тестировании\nCharles Proxy Прокси для помощи в тестировании приложения. Статья в CF\n"});index.add({'id':9,'href':'/avito-android/assemble/buildmetrics/','title':"BuildMetrics",'content':"Метрики сборки Собираем с каждой сборки:\n Время сборки Время конфигурации проекта Эффективность кеширования  Собираем каждую метрику со следующими атрибутами:\n Успешная\\упавшая сборка Окружение: локальная сборка или CI Пользователь (для локальных сборок) Имя хоста (для сборок в CI)  Часть метрик доступна с большей детализацией:\n Аргументы запуска - какую задачу запускали Модуль  Dashboards  Время сборки  Общее время сборки Время сборки в разрезе пользователей и задач Бенчмарки Нестандартные настройки проекта   Статистика по задачам Время конфигурации Эффективность кеширования Общая статистика по сборкам  Реализация Собираем плагином com.avito.android.build-metrics (build-metrics).\n"});index.add({'id':10,'href':'/avito-android/categories/','title':"Categories",'content':""});index.add({'id':11,'href':'/avito-android/cd/','title':"Cds",'content':""});index.add({'id':12,'href':'/avito-android/checks/','title':"Checks",'content':""});index.add({'id':13,'href':'/avito-android/ci/cigradleplugin/','title':"CI Gradle Plugin",'content':"CI Gradle plugin Для настройки CI под конкретный gradle модуль используется in-house плагин.\nРешает задачу точечной настройки типа и строгости проверок для разных сценариев.\nplugins { id(\u0026#34;com.avito.android.cd\u0026#34;) } builds { ... } Применяется например в модуле приложения, однако нет никаких ограничений, чтобы применить плагин как-то иначе (см. ./build.gradle)\nBuilds Используется набор захардкоженых сценариев(builds):\nbuilds { fastCheck { ... } }  localCheck - проверки компиляции на локальной машине fastCheck - максимально быстрые проверки, выполняющие требования к CI fullCheck - максимально полные проверки, можем жертвовать скоростью release - набор действий необходимых для предоставления всех релизных артефактов  Steps Внутри сценариев описываем декларативно необходимые шаги:\nfastCheck { uiTests {} }  configuration - проверить конфигурацию проекта, модуль build-script-test uiTests - запустить ui тесты модуля performanceTests - запустить перформанс тесты модуля compileUiTests - скомпилировать androidTest модуля unitTests - запустить юнит тесты модуля и всех его зависимостей lint - запустить android lint по настройкам в модуле docsDeploy - опубликовать документацию в k8s (отключено) docsCheck - запустить проверки документации uploadToQapps - загрузить указанные артефакты в QApps uploadToArtifactory - загрузить указанные артефакты в Artifactory uploadToProsector - загрузить указанные артефакты в Prosector uploadBuildResult - загрузить указанные артефакты в сервис релизов deploy - загрузить указанные артефакты в google play artifacts - зарегистрировать артефакты в качестве результатов билда.\nДобавит проверку на их наличие и возможность загрузить при помощи других тасок.  Сценарий может использовать Impact analysis(по-умолчанию отключено):\nfastCheck { uiTests { useImpactAnalysis = true } } SuppressibleBuildStep В разных сценариях падения шагов могут ронять за собой весь билд, а можно настроить чтобы билд не упал. Обработка этого флага должна быть явно поддержана шагом.\nfastCheck { uiTests { suppressFailures = false } } release { uiTests { suppressFailures = true } } Custom steps По необходимости добавляем свои шаги, наследуясь от com.avito.ci.steps.BuildStep\nArtifacts Артефакты, которые планируется как-то использовать нужно зарегистрировать специальным образом\nartifacts { file(\u0026#34;lintReport\u0026#34;, \u0026#34;${project.buildDir}/reports/lint-results-release.html\u0026#34;) } Есть разные типы артефактов, различаются по типам проверок и способу описания путей\n apk - достает apk по buildType и проверяют пакет и подпись bundle - достает bundle по buildType и проверяют пакет и подпись mapping - достает mapping по buildType и проверяют наличие file - простой доступ к файлу по пути и проверка на наличие  artifacts { apk(\u0026#34;releaseApk\u0026#34;, RELEASE, \u0026#34;com.avito.android\u0026#34;, apkPath(\u0026#34;release\u0026#34;)) { signature = releaseSha1 } bundle(\u0026#34;releaseBundle\u0026#34;, RELEASE, \u0026#34;com.avito.android\u0026#34;, bundlePath(\u0026#34;release\u0026#34;)) { signature = releaseSha1 } mapping(\u0026#34;releaseMapping\u0026#34;, RELEASE, \u0026#34;${project.buildDir}/outputs/mapping/release/mapping.txt\u0026#34;) file(\u0026#34;featureTogglesJson\u0026#34;, \u0026#34;${project.buildDir}/reports/feature_toggles.json\u0026#34;) } Первый аргумент - регистрирует ключ, который затем используется в upload шагах для указания артефактов\n"});index.add({'id':14,'href':'/avito-android/ci/civalues/','title':"CI Values",'content':"Требования к Continuous Integration Польза Проверки помогают не допускать ошибки\nСкорость получения фидбека Ожидаем что билд идет не больше 30 минут\nПонятность фидбека При падении однозначно понимаем в чем проблема\nНет лишнего шума (бесполезных warning'ов на которые неизвестно как реагировать)\nДетерминизм Запуски на том же коммите должны приводить к одинаковым результатам\n"});index.add({'id':15,'href':'/avito-android/ci/','title':"Cis",'content':""});index.add({'id':16,'href':'/avito-android/ci/impactanalysis/','title':"Code review",'content':"Impact analysis Импакт анализ находит измененные файлы и запускает минимально возможный набор проверок. Это всегда баланс между скоростью проверок и их полнотой.\nОписание подхода: The Rise of Test Impact Analysis\nUI тесты Обзор реализации для автотестов: Android CI Impact analysis.\nИмпакт анализу нужна помощь в привязке экрана к модулю. Для этого проставляем Screen.rootId.\nОграничения В импакт анализе есть два типа ошибок:\n Не запустили, то что было задето. Запустили больше, чем было задето (fallback).\nОтдаем этому варианту предпочтение.  Известные сценарии fallback'ов:\n Точность до уровня теста: если задет класс, запустим все его тесты. Точность до уровня модуля: если задет модуль, запустим все тесты связанные с package этого модуля. Запустим все тесты связанные с Screen, если не можем найти его package:  Screen не соответствует ни одному пакету Screen соответствует нескольким пакетам    "});index.add({'id':17,'href':'/avito-android/contributing/codereview/','title':"Code review",'content':"Code review / Pull request Инспекция кода проводится для всех изменений в репозитории. Она проводится при отправке изменений в любую ветку, кроме feature. Просмотр и одобрение кода доступно всем разработчикам, но на отправку кода в develop, master накладываются ограничения.\nЦели инспекции кода Улучшение качества кода и продукта:\n Поиск и устранение ошибок и уязвимостей Оценка поддерживаемости, удобства использования Проверка на соответствие принятым стандартам (того, что невозможно или нецелесообразно автоматизировать)  Для команды:\n Совместное владение кодом, уменьшение фактора автобуса Обучение и наставничество Развитие культуры команды  Best practices Избегаем крупных PR Большие изменения делают неэффективной инспекцию кода, порождают конфликты. Применяем следующие подходы:\n Декомпозируем задачу и делаем в отдельных ветках, сливая более мелкими частями При возможности используем feature toggle, чтобы не держать долгоживущие ветки Изменения общих классов стараемся заранее выносить в отдельный PR. Например, начал делать задачу и видишь что нужно сильно менять модель данных. Лучше сделать это отдельным рефакторингом до реализации бизнес-функциональности.  Основная идея: develop играет роль CI при реализации задач. Лучше уменьшать интгерационные проблемы, сливать чаще, меньшими частями, работать на упреждение. Принимаем определенные риски, но размываем их по мелким задачам, так с ними проще бороться.\nПравило бойскаута или оппортунистический рефакторинг Opportunistic refactoring (Martin Fowler).\nПри необходимости рефакторинга стараемся заложить его в оценку бизнес-задачи, не откладывать на потом. Если совсем небольшой, то можно прямо в основной задаче, но желательно отдельным коммитом.\nНе переходи на личности. Обсуждай код, но не автора Это правило трудно переоценить, но оно лишь необходимое, но не достаточное условие. Даже в этом случае критика может быть принята в отношении человека. Нужно уметь критиковать, доносить предложения.\nБез оскорблений и ругательств У всех разное чувство юмора и поэтому даже безобидные на первый взгляд выражения могут быть восприняты оскорбительно.\nБез требовательных и вызывающих выражений Если смысл комментария можно свести к фразе \u0026ldquo;ты неправ\u0026rdquo;, например:\n \u0026ldquo;Так не сработает\u0026rdquo; \u0026ldquo;Совершенно неправильно\u0026rdquo; \u0026ldquo;Почему ты просто не …?\u0026rdquo;  Это неконструктивно, как минимум. Необходимо объяснить суть претензии, предложить решение.\nНе будь пассивно-агрессивным Не надо демонстрировать раздражение, избегай неприятных фраз и претензий:\n \u0026ldquo;Ещё раз повторяю: здесь нужно…\u0026rdquo; \u0026ldquo;Как я уже говорил…\u0026rdquo; \u0026ldquo;Как скажешь, делай как хочешь\u0026rdquo; \u0026ldquo;Если кому-нибудь вообще интересно, …\u0026rdquo;  Не нарушай правило «Никаких сюрпризов» Избегаем неожиданностей. Требования должны быть явные и зафиксированы в соглашениях.\nНе будь непрошенным советчиком Целью рецензирования не должно стать принуждение написать код так, как бы тебе хотелось. Уважай право автора на собственные решения, если они обоснованы. Главное — качественный, удобный в сопровождении код. Слишком много обсуждений не по существу скорее запутают, отвлекут от важного.\nУчитывай свои цели Всегда принимай во внимание то, чего хочешь достичь комментарием? Указать на конкретную проблему в коде? Помочь или подсказать? Или может быть только показать какой ты умный и подтвердить свою правоту? Иногда лучше держать своё мнение при себе.\nХвали хороший код Положительные комментарии хороших решений помогают лучше реагировать на критику, снимают напряженность в общении. Только без наигранности и слащавости, комментировать решения по сути. Также можно комментировать логику, свое понимание изменений (монолог на ходу). Это дает дополнительный шанс проверить корректность и понимание работы.\nИзбегай обвинений Лучше спрашивать, а не обвинять и делать громкие заявления. Это улучшает восприятие, направляет в сторону решения, а не рефлекторной обороны от обвинений. Будь осторожен с вопросами \u0026ldquo;Почему?\u0026quot;. Они могут звучать обвинительно.\n👎\n «Здесь ты не соблюдал стандарты» «А — неправильно, надо использовать В» «Запутанный код» «Ты не сделал X» «Почему ты просто не …?»   👍\n «Какие причины выбора такого решения?» «Зачем ты использовал A вместо B?» «Эта часть мне непонятна. Можешь объяснить?» «Я не нашёл, где сделано X» «Чем ты руководствовался, когда …?»    Объясняй причину Поясняй причину, что конкретно улучшит предлагаемое изменение.\nWorkflow Создание PR  PR создается после реализации функциональных требований. Для декомпозиции и уменьшения PR используем отдельные [под]задачи. Допустимо создание промежуточных PR для небольших рефакторингов, но декомпозиция работ должна быть осмысленная. Это не должно приводить к грязному develop. Все это обязательно комментируем. Иначе такой PR формально можно отклонить как недоделанный. Рекомендуется превентивно прокомментировать неочевидные места, пояснить решения, чтобы рецензенты лучше вникли в суть задачи и проверили более качественно. При необходимости, в описании PR можно пометить (в свободной форме) возможность слияния. По умолчанию это может делать только создатель.  Рецензенты (reviewers) Любой PR необходимо смотреть и комментировать всем членам команды. Это важный способ обмена знаниями. По умолчанию, при создании PR, список рецензентов пустой. Но можно указать желаемых участников.\nПеред началом просмотра Добавить себя в список рецензентов. Так обозначаем, что начали рецензирование. При невозможности закончить, необходимо удалить себя из списка рецензентов.\nВ процессе Что проверяем?\n  Соответствие принятым стандартам и соглашениям\n  PR содержит изменения только по заявленной в задаче функциональности\n  По возможности, сразу создаем задачи с конкретными предложениями. Это удобное средство, упрощающее отслеживание исправлений. Нельзя слить PR, если в нем есть незавершенные задачи.\n  Комментарии, не требующие никакой ответной реакции, являются исключением и помечаются специально. Для них пишем \u0026ldquo;FYI \u0026hellip;\u0026rdquo;\n  Неактуальные комментарии можно не удалять, а оставлять намеренно в угоду сохранения истории обсуждения. Подобные комментарии могут быть маркером неочевидных решений, плохо читаемого кода и т.п.\n  По окончании Явно отражаем бинарный результат:\n Approve - можно сливать, полностью устраивает в таком виде. Needs Work - требуются доработки (любые).  Этот статус не надо рассматривать как оценку качества.\nОн лишь констатирует факт - сливать в таком виде еще нельзя.\nРекомендуется ставить при наличии любых блокеров (конфликты, открытые задачи, \u0026hellip;). Мотивация: если в PR отмечено что можно сливать и все поставят апрувы при наличии открытых задача, то после закрытия задач можно случайно смержить еще до пуша исправлений. Поэтому апрув должен быть явный, не впрок.\nDecline неудобен тем, что теряется история обсуждений. Используем только если хотим полностью отменить PR.\nАвтор По каждому комментарию дает обратную связь:\n Исправить код, если все очевидно. Краткое описание изменений удобно делать в задачах. По каждому исправлению необходимо дать ответ, что и как именно исправлено (рекомендуется выразить это задачей). Если что-то сделано намеренно, то необходимо пояснить причины. На открытые вопросы необходимо дать ответы.  При наличии одобрения от всех рецензентов сливает изменения.\nПроблемные сценарии Случайное бекпортирование при слиянии в несколько веток - создавать PR последовательно:\nСначала сливаем в \u0026ldquo;более стабильную” (release и т.п.) ветку, исправляем замечания и т.п.\nПотом сливаем в \u0026ldquo;более новую\u0026rdquo; (develop) ветку, уменьшая риск случайного бэкпортирования.\nPR в более стабильные ветки необходимо создавать сразу, не откладывать на потом. Конфликты лучше решать сразу, не накапливать.\nДругое В описании PR, относящихся к задачам по обновлению версии библиотек, необходимо указывать What's new для новой версии библиотеки.\nМотивация: предоставить рецензентам весь контекст, чтобы обсуждать более предметно.\nМатериалы по теме  Как подписаться на изменения в модулях? Code Ownership Plugin Рекомендации Google: How to do a code review  "});index.add({'id':18,'href':'/avito-android/contributing/codestyle/','title':"Code style",'content':"Code Style Автоматизация Editor config За настройку code style отвечает editor config. А точнее плагин для IDE.\nНужно убедиться, что плагин установлен и включен (Preferences \u0026gt; Plugins \u0026gt; Installed \u0026gt; search: EditorConfig)\nПосле этого все настройки авто-формата должны применяться по порядку:\n EditorConfig настройка на уровне папки EditorConfig настройка на уровне проекта Личная настройка в IDE (если не определены настройки выше)  Правила определены в .editorconfig в корне проекта. И переопределены в папках где значения по-умолчанию не устраивают (например ci/docker/android-builder/.editorconfig).\n.idea/codeStyles (legacy) Отказались от использования xml, которые сохраняет IDE. Разные версии Android Studio автоматически вносят изменения в файл настроек и это невозможно отключить. Как итог, получали нежелательные и конфликтующие изменения. Это отвлекает и мешает использовать разные версии IDE.\nЕсли автоматика сломалась Порой по разным причинам автоматические настройки code style слетают, это больное место в Android Studio. Причиной может быть к примеру обновление версии.\nВыставить настройки близкие к автоматическим можно так:\n Preferences -\u0026gt; Editor -\u0026gt; Code Style установить Hard wrap - 120 Preferences -\u0026gt; Editor -\u0026gt; Code Style -\u0026gt; Kotlin Set From -\u0026gt; Predefined Style -\u0026gt; Kotlin Style Guide Imports -\u0026gt; Use single name import в обоих опциях Imports -\u0026gt; Packages to Use Imports with * - удалить все  Проверки в CI В данный момент соответствия code style проверяются вручную на Code Review (Задача на автоматизацию).\nCode guidelines Именование Packages  Не должен содержать заглавные символы, чтобы избегать конфликтов с интерфейсами и классами. Допускается использования символа _  С точки зрения бизнес-модулей стараемся делать плоскую структуру пакетов, не привязываясь к навигации. Примеры:\n categories вместо category/list  Variables  Детальность названия должна соответствовать области видимости. Не экономим на буквах в ущерб читаемости. Сокращения допустимы для общепринятых терминов.  val ctx: Context val context: Context  Имя должно отражать смысл. Избегаем излишних знаний про реализацию и тип данных.  val bundle: Bundle val state: Bundle Kotlin Используем Kotlin official style guide\nFile structure Extension функции и свойства рекомендуется располагать в файле с названием расширяемого класса во множественном числе. Исключение: Если extension относится к типизированной коллекции, то он должен располагаться в файле с названием типа а не коллекции. Мотивация: однозначный поиск, не нужно думать куда это положили. Пример:\nViews.kt: fun View.hide() = ... Dimensions.kt: fun List\u0026lt;Dimension\u0026gt;.findByRatio() = ... Lists.kt: fun List\u0026lt;T\u0026gt;.second() = ... Публичные классы и файлы В файле должно быть не более одного публичного класса\\интерфейса\\аннотации... Исключение делаем для вырожденных реализаций интерфейса, которым нельзя придумать осмысленного именования и из-за этого не может быть нескольких имплементаций (...Impl и т.п.).\nМотивация: нужны простые и однозначные правила для навигации, иначе имя файла становится бесполезным. Если каждый будет располагать согласно предпочтениям, то это может привести к бесконечному рефакторингу и лишним спорам.\nКонстанты Константные значения на уровне файла называем в нотации ALL_UPPER_CASE. Значения для строковых констант по возможности пишем в snake_case. Не мусорим в пространстве имен: обязательно используем минимально возможную видимость (private если используется только в этом файле, internal если используется только в пределах модуля). Примитивные значения и строки дополнительно помечаем модификатором const\nprivate const val KEY_MESSAGE = “key_fragment_message\u0026#34; internal const val INVALID_POSTIION = Int.MIN_VALUE Аргументы функций Неочевидные аргументы необходимо именовать при вызове.\nPlatform types Избегаем платформенные типы. При взаимодействии с Java кодом указывать типы явно, чтобы избежать потенциальных ошибок.\nval fooId = arguments.getString(KEY_FOO_ID) // --\u0026gt; String! val fooId: String? = arguments.getString(KEY_FOO_ID) // --\u0026gt; String? Reified type parameters При наличии альтернативы предпочтительно вывести тип автоматически, средствами языка, чтобы избежать возможных ошибок при приведении типа:\nval location = readParcelable(Profile::class.java.classLoader) val location = readParcelable() Комментарии Комментирование кода Комментариев избегаем. Используем только для пояснения неочевидных моментов, но максимально пытаемся выразить смысл кодом. Временное комментирование кода допускается в feature ветках. От неиспользуемого кода избавляемся и не пытаемся использовать комментарии вместо VCS. Мотивация: устаревание комментариев, они начинают врать, а это хуже чем их отсутствие.\nПри необходимости временно закомментировать участок кода предпочтительно использовать // комментарии вместо /* */. Мотивация: проще редактировать, т.к. у каждой строки нет \u0026ldquo;контекста\u0026rdquo;. Например, проблемно раскомментировать несколько строк внутри /* */ комментария.\nКомментирование решений При необходимости пояснить решение избегаем комментарии. Необходимо выражать смысл кодом - в названиях переменных, методов и т.п. Пример - дублирование if, который не поясняет смысл проверки. Мотивация: код должен быть самодокументируемым. Комментарии легко устаревают, становятся ложными и могут даже навредить, введя в заблуждение (см. Clean Code)\nTODO комментарии Допускаются комментарии вида // TODO comment Обязательно наличие пояснения. Rule of thumb: из комментария сразу должна быть понятна суть. Иначе этот комментарий не нужен.\nDeprecations Когда в коде появляется новый класс или метод, который дублирует функции уже существующего, то желательно удалять старый. Если такой возможности нет, то помечаем старый класс или метод аннотацией @Deprecated, но обязательно с комментарием и указателем на новый. Для kotlin аннотации @Deprecated обязательными для заполнения параметрами являются message и replaceWith.\nImports Fully qualify imports This is bad: import foo.* This is good: import foo.Bar Мотивация: используемые зависимости очевидны, меньше конфликтов. Читаемость и поддерживаемость важнее. Источник\nOrdering Порядок методов и полей Публичное преимущественно располагаем в начале класса, приватное и с большей детализацией - ниже. Метод должен быть при возможности сразу после места его использования. Мотивация: основная цель - обеспечить хорошую читаемость кода. В идеале код должен читаться как рассказ. Для этого надо минимизировать навигацию при чтении.\nXML Размеры, отступы и кегли шрифтов выносим в dimens.xml, если они повторяются или имеют разные значения для разных конфигураций экранов. Даем осмысленные имена в snake_case. Пример: \u0026lt;dimen name=\u0026quot;list_card_vertical_padding\u0026quot;\u0026gt;4dp\u0026lt;/dimen\u0026gt; Мотивация: быстрая адаптация верстки к различным экранам.\nLayout называем придерживаясь правила \u0026lt;where\u0026gt;[_\u0026lt;description\u0026gt;].xml\n \u0026lt;where\u0026gt; описывает экран или его логическую часть. \u0026lt;description\u0026gt; - необязательное описание. Может включать в себя маркеры типа: activity, fragment и тп.  Пример: profile_editor.xml, offer_common_part.xml, balance.xml, order_item.xml Мотивация: быстрая и удобная навигация в папках с ресурсами, благодаря переносу смысловой нагрузки в начало. order[_activity].xml вместо activity_order.xml\nС помощью FOLDING_PLUGIN, можно добиться групирования по виртуальным папкам.\nview id именуем в snake_case. Пример: android:id=\u0026quot;@+id/category_title\u0026quot;.\nСтили называем в PascalCase. Пример: \u0026lt;style name=\u0026quot;AvitoButton.Transparent\u0026quot;\u0026gt;.\n"});index.add({'id':19,'href':'/avito-android/contributing/','title':"Contributings",'content':""});index.add({'id':20,'href':'/avito-android/ci/customgradleplugins/','title':"Custom Gradle Plugins",'content':"Custom Gradle plugins Вся логика CI расположена в in-house gradle плагинах. Для тестирования корневого проекта смотри модуль build-script-test.\nHow to start Начни с официальных туториалов, они сэкономят время:\n Gradle plugin development tutorials\nДля нас не актуальна только публикация плагинов. Custom tasks  Если что-то не понятно, здесь тебе помогут:\n #gradle gradle-community.slack.com  Работа с плагинами в IDE  Предпочтительно использовать IntelliJ IDEA Import project Согласись использовать gradle wrapper Settings \u0026gt; Build, Execution, Deployment \u0026gt; Build Tools \u0026gt; Gradle \u0026gt; Runner  Delegate IDE build/run actions to gradle (check) Run tests using : Gradle Test Runner    Теперь можно запускать тесты по иконкам run\nKnown issues:\n Имя теста (DynamicTest.displayName) некорректно отображается в IDE: #5975  Debugging Для тестов работает из IDE.\nДля отладки плагина:\n Добавь в IDE конфигурацию Remote для запуска, как для обычного java проекта. Запускай gradle из корня репозитория с параметрами -Dorg.gradle.debug=true --no-daemon  Debugger работает не только в нашем коде, остановиться можно и в AGP или Gradle.\nТестирование Запуск тестов из консоли ./gradlew test\nЧтобы не останавливать прогон тестов на первом падении добавь --continue\nДля запуска отдельного теста, класса или пакета работает фильтр: --tests package.class.method, но нужно запускать тесты для отдельного модуля, иначе фильтр упадет не найдя нужных тестов по фильтру в первом попавшемся модуле.\nBest practices Feature toggles Плагин может сломаться и заблокировать всем работу с проектом. Чтобы дать себе время на исправление, делай плагин отключаемым:\nopen class MyPlugin : Plugin\u0026lt;Project\u0026gt; { override fun apply(project: Project) { // В каждом property используем префикс `avito.\u0026lt;plugin\u0026gt;`  // сразу видно где используется  if (!project.getBooleanProperty(\u0026#34;avito.my_plugin.enabled\u0026#34;, default = false)) { project.logger.lifecycle(\u0026#34;My plugin is disabled\u0026#34;) return } Тогда каждый разработчик сможет локально отключить плагин в случае проблем.\nДиректория ci Там храним всю интеграцию с CI.\nЧасто нужно править плагин совместно с ./ci/\nЧтобы работать одновременно со всем этим кодом, к уже открытому проекту добавь модуль ci: File \u0026gt; New \u0026gt; Module from existing sources \u0026gt; путь до папки ci \u0026gt; ok \u0026gt; ok\nИнтеграция плагина в CI CI Gradle Plugin\nДополнительные материалы  Интеграция с AGP 4+  "});index.add({'id':21,'href':'/avito-android/assemble/dependencies/','title':"Dependencies",'content':"Зависимости Как подключить внешнюю зависимость? Все зависимости объявляем в одном файле - Dependencies.kt.\nНа них ссылаемся в build.gradle модуля:\ndependencies { implementation(Dependencies.supportAnnotations) Как зафорсить версию зависимости? Конфигурация проекта упадет, если в транзитивных зависимостях прилетают разные версии одной и той-же библиотеки:\n\u0026gt; Conflict(s) found for the following module(s): - com.google.android.gms:play-services-measurement-api between versions 17.2.1 and 17.0.0 Run with: --scan or :avito:dependencyInsight --configuration debugRuntimeClasspath --dependency com.google.android.gms:play-services-measurement-api to get more insight on how to solve the conflict. В приложении должна быть только одна версия.\nВыбери подходящую версию (обычно берем старшую) и добавь зависимость в Dependencies.\nАвтоматически форсим версии для всех зависимостей из Dependencies (см. applyDefaultResolutionStrategy).\n"});index.add({'id':22,'href':'/avito-android/architecture/dagger/','title':"Dependency Injection with Dagger",'content':"Dagger Материалы Обязательно прочесть  Документация Тредик на гитхабе с tips \u0026amp; tricks для kotlin  Рекомендую к изучению  Видео от одного из авторов Dagger Ron Shapiro, о том, как правильно его готовить Немного устаревшая статья про правильное приготовление dagger  ⚠️ Нельзя постигнуть даггер, не смотря какой код он генерирует!  Как правильно работать с Dagger  Поддерживаемость прежде всего. Граф зависимостей делай маскимально простой и понятный Application Component имеет минимальный скоуп - содержит не более необходимого чилсла зависимостей Если зависимость может быть не глобальной, оне должа быть в скоупе экрана, а не приложения Меньше мокай в instrumentation-тестах  Provides → Binds Используй Binds вместо Provides по-возможности всегда\n👍 Dagger генерирует меньше классов и получается более эффективный код.\n👍 Проще писать Module-классы и изменять код, как в конструкторах, так и в Module-классах.\nВ самом простом случае необходимо добавить к объявлению класса @Inject constructor и переделать метод класса на абстрактный, который связывает интерфейс и реализацию:\nБыло:\n@Provides @PerFragment internal fun provideSearchDeepLinkInteractor( api: SearchApi, searchParamsConverter: SearchParamsConverter, schedulersFactory: SchedulersFactory ): SearchDeepLinkInteractor { return SearchDeepLinkInteractorImpl(api, searchParamsConverter, schedulersFactory) } Стало:\n@Binds @PerFragment fun bindsSearchDeepLinkInteractor(interactor: SearchDeepLinkInteractorImpl): SearchDeepLinkInteractor Было:\nclass SearchDeepLinkInteractorImpl( private val api: SearchApi, private val searchParamsConverter: SearchParamsConverter, private val schedulers: SchedulersFactory ) : SearchDeepLinkInteractor Стало:\nclass SearchDeepLinkInteractorImpl @Inject constructor( private val api: SearchApi, private val searchParamsConverter: SearchParamsConverter, private val schedulers: SchedulersFactory ) : SearchDeepLinkInteractor Когда использовать @Provides Когда идет любое конфигурирование/инициализация, например features. Dagger - инструмент DI. Старайтесь минимально заниматься решением задач не связанных с DI через Dagger. Меньше кода в Dagger-модуле - лучше.\n@Provides @PerFragment internal fun providePermissionHelper(features: Features, dialogRouter: DialogRouter): PermissionHelper { val permissionHelper = FragmentPermissionHelper(fragment) return if (features.geoPermissionDialog.value) { LocationPermissionHelperWrapper(permissionHelper, dialogRouter) } else { permissionHelper } } Если нужно мокать методы модуля для тестирования. Мокать binds-методы не имеет смысла - это просто источник информации для процессора Dagger.\nИнстанциирование сторонних классов. Невозможно прописать Inject в конструктор класса, к исходному коду которого нет доступа.\n@Provides @JvmStatic internal fun provideAdapterPresenter(provider: ItemBinder): AdapterPresenter { return SimpleAdapterPresenter(provider, provider) } Static providers: object При использовании @Provides объявляй класс object.\n👍 В этом случае R8 удалит всю инициализацию и может заинлайнить методы (они будут действительно статическими).\n@Module object Module { @Provides fun provideObject(): Object { return Object() } } 👎 Нельзя мокать модули в тестах, что не часто нужно.\nIntoSet / IntoMap Используй IntoSet (IntoMap). Проставь JvmSuppressWildcards, чтобы Dagger понял какого типа вам нужны данные.\n👍 Позволяет в разных модулях собирать необходимые вам объекты в список.\nЧтобы подключить новый класс и он долетел куда нужно достаточно соблюсти интерфейс, и добавить IntoSet (IntoMap) @Binds @IntoSet fun bindCategorySettingsItemBlueprint(blueprint: CategorySettingsItemBlueprint): ItemBlueprint\u0026lt;*, *\u0026gt; @Binds @IntoSet fun bindLogoWithVersionSettingsItemBlueprint(blueprint: LogoWithVersionSettingsItemBlueprint): ItemBlueprint\u0026lt;*, *\u0026gt; @Provides @PerActivity internal fun provideItemBinder( blueprints: Set\u0026lt;@JvmSuppressWildcards ItemBlueprint\u0026lt;*, *\u0026gt;\u0026gt; ): ItemBinder { return with(ItemBinder.Builder()) { blueprints.forEach { registerItem(it) } build() } } 👎 В сложной иерархии модулей может потеряться контроль над тем, что прилетает из графа dagger.\n👎 Необходимо использовать квалификтаторы (Named), в случае если интерфейсы клэшатся и нужно сделать два набора данных\nScope overuse Не злоупотребляй скоупами без надобности.\nКаждый скоуп, кроме Reusable (Singleton, PerActivity, PerFragment, etc) порождает использование Dagger-класса DoubleCheck, который реализует проверку DoubleCheckLock для гарантий Singleton.\npublic T get() { Object result = instance; if (result == UNINITIALIZED) { synchronized (this) { result = instance; if (result == UNINITIALIZED) { result = provider.get(); instance = reentrantCheck(instance, result); /* Null out the reference to the provider. We are never going to need it again, so we * can make it eligible for GC. */ provider = null; } } } return (T) result; } Reusable scope порождает проверку SingleCheck, которая менее строгая:\npublic T get() { Object local = instance; if (local == UNINITIALIZED) { // provider is volatile and might become null after the check, so retrieve the provider first  Provider\u0026lt;T\u0026gt; providerReference = provider; if (providerReference == null) { // The provider was null, so the instance must already be set  local = instance; } else { local = providerReference.get(); instance = local; // Null out the reference to the provider. We are never going to need it again, so we can  // make it eligible for GC.  provider = null; } } return (T) local; } Component.Builder → Component-Factory 👍 Ошибка когда при создании компонента забывают вызвать один из методов билдера вылетит во время компиляции а не в рантайме.\nБыло:\ninterface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Builder interface Builder { fun settingsDependencies(settingsDependencies: SettingsDependencies): Builder fun locationDependencies(locationDependencies: LocationDependencies): Builder @BindsInstance fun state(state: Kundle?): Builder @BindsInstance fun resources(resources: Resources): Builder @BindsInstance fun settingsItemsStream(settingsItemsStream: PublishRelay\u0026lt;String\u0026gt;): Builder fun build(): SettingsComponent } } Стало:\ninterface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Factory interface Builder { fun create( settingsDependencies: SettingsDependencies, locationDependencies: LocationDependencies, @BindsInstance state: Kundle?, @BindsInstance resources: Resources, @BindsInstance settingsItemsStream: PublishRelay\u0026lt;String\u0026gt; ): SettingsComponent } } Лучше именовать параметры при вызове, чтобы не перепутать, если есть аргументы одного типа идущие последовательно:\nDaggerSettingsComponent.factory() .create( settingsDependencies = findComponentDependencies(), locationDependencies = findComponentDependencies(), state = savedInstanceState?.getKundle(KEY_SETTINGS_PRESENTER), resources = resources, settingsItemsStream = PublishRelay.create() ) .inject(this) BindInstance → stateless module 👍 Вы сможете провайдить объект в дерево Dagger не добавляя его в конструктор модуля.\nЭто сделает его статическим, что хорошо. См. пункт 1 про статические провайдеры.\nБыло:\n@Component(modules = [SettingsModule::class]) interface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Factory interface Factory { fun module(module: SettingsModule): Builder fun create(): SettingsComponent } } class SettingsModule(val kundle: Kundle) {...} Стало:\n@Component(modules = [SettingsModule::class]) interface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Factory interface Factory { @BindsInstance fun create(state: Kundle?): Factory } } object :SettingsModule() {...} Хорошее правило:\n✅ Singleton (PerActivity, PerFragment), если важна гарантия единственности\n✅ Reusable - если singleton нужен для оптимизации\n✅ во всех остальных случаях избегайте скоупов Перевод субкомпонентов уровня Application в компоненты Проблема Subcomponents в сгенерированном коде - это вложенный класс в Component.\nПоэтому использовать subcomponent для фичей\\экранов дорого:\n Ломает compilation avoidance: каждое изменение субкомпонента приводит к перегенерации компонента в avito (самый тяжелый модуль с тестами). Хуже масштабируется: ApplicationComponent распухает, содержит все фичи, растет время его компиляции. Дольше инициализации ApplicationComponent  Решение  Не использовать subcomponent на уровне Application, выделить отдельные Dagger-компоненты в gradle-модулях. Внутри компонента на уровне модули использовать субкомпоненты уже не проблема, не аффектит все приложение.  Тогда основной даггер-граф из Application вообще может не перегенерироваться при изменении в gradle-модулях (бывшие субкомпоненты).\nАлгоритм  Выявить интерфейсы, которые нужны и будут прилетать из основного (application) дерева Dagger.\nНайти их можно по использованию. Они инжектятся напрямую, либо используются в модулях.\nЕсли сразу непонятно, какие интерфейсы понадобятся, можно сделать пустой интерфейс и заполнять его по мере того, как Dagger будет сообщать о том, что не хватает.  interface SettingsDependencies : ComponentDependencies { } Выделить их в отдельный интерфейс, отнаследовав от ComponentDependencies:\n⚠️ Это самый сложный этап, где Dagger ругается что ему не хватает из основного графа, а вы выписываете недостающее.\nДля часто используемых общих зависимостей выделили CoreComponentDependencies.  interface SettingsDependencies : ComponentDependencies { fun activityIntentFactory(): ActivityIntentFactory fun context(): Context fun startupStorage(): StartupStorage fun deviceIdProvider(): DeviceIdProvider fun schedulersFactory(): SchedulersFactory fun profileInfoStorage(): ProfileInfoStorage fun deviceMetrics(): DeviceMetrics fun debugIntentFactory(): DebugIntentFactory } Eсли используются дополнительные модули (например, SavedLocationInteractorModule), у них могут быть готовые интерфейсы:  interface LocationDependencies : ComponentDependencies { fun locationApi(): LocationApi fun savedLocationStorage(): SavedLocationStorage } Отнаследовать ApplicationComponent от интерфейсов из прошлых шагов:  interface ApplicationComponent : BaseApplicationComponent, LocationDependencies, SettingsDependencies, ... } Добавить в ComponentDependenciesModule маппинг нового ComponentDependencies:  @Binds @IntoMap @ComponentDependenciesKey(SettingsDependencies::class) abstract fun provideSettingsDependencies(component: ApplicationComponent): ComponentDependencies @Binds @IntoMap @ComponentDependenciesKey(LocationDependencies::class) abstract fun provideLocationDependencies(component: ApplicationComponent): ComponentDependencies Изменить субкомпонент на компонент, или создать новый такого вида:  @PerActivity @Component( dependencies = [SettingsDependencies::class, LocationDependencies::class], //Необходимые зависимости  modules = [SettingsModule::class, SavedLocationInteractorModule::class] //Необходимые модули ) interface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Factory interface Builder { fun create( settingsDependencies: SettingsDependencies, locationDependencies: LocationDependencies, @BindsInstance state: Kundle?, @BindsInstance resources: Resources, @BindsInstance settingsItemsStream: PublishRelay\u0026lt;String\u0026gt; ): SettingsComponent } } В Activity/Fragment код изменится подобным образом:  import com.avito.android.di.findComponentDependencies import com.avito.android.DaggerSettingsComponent ... DaggerSettingsComponent.factory() .create( settingsDependencies = findComponentDependencies(), locationDependencies = findComponentDependencies(), state = savedInstanceState?.getKundle(KEY_SETTINGS_PRESENTER), resources = resources, settingsItemsStream = PublishRelay.create() ) .inject(this) ⚠️ Важно добавить в импортах перед SettingsComponent слово Dagger (DaggerSettingsComponent). Дело в том, что это кодогенерированный класс и на этапе написания кода он недоступен.\nСбилдить и запустить. Все готово!\nKnown Issues IDE не видит сгенерированные файлы Компонент отображается красным, как будто его нет.\n Проверь что файлы kapt не добавлены в исключения: Preferences \u0026gt; Editor \u0026gt; File Types \u0026gt; Ignore Files and Folders  Dagger: error.NonExistentClass cannot be provided / converted error.NonExistentClass cannot be provided without an @Inject constructor or an @Provides-annotated method e: MyClass.java:15: error: incompatible types: NonExistentClass cannot be converted to Annotation @error.NonExistentClass() ^ Dagger не видит этот класс из сгенерированного кода.\nПроверь что подключен соответствующий модуль с этим классом. Ошибка может врать, поэтому лучше проверить доступность всех классов, используемых в модуле.\n"});index.add({'id':23,'href':'/avito-android/test/dynamicconfig/','title':"Dynamic config",'content':"Запуск тестов в CI с кастомными параметрами В Teamcity есть конфигурация instrumentationDynamic для запуска тестов со специфическим набором требований.\nЗапускайте и вам будет предложено выбрать:\n Ветку для запуска Версии API Фильтр для выбора тестов (package prefix), можно задать пакет [+ имя класса [+ имя тестового метода ]] Количество запусков. Полезно для отладки нестабильных тестов  "});index.add({'id':24,'href':'/avito-android/contributing/featuretoggles/','title':"Feature toggle",'content':"Feature toggle  Feature toggle (Wikipedia) Feature toggle (Martin Fowler) Feature Toggles (Pete Hodgson)  Используется для уменьшения рисков при внедрении новой функциональности. Позволяет:\n Не держать изменения в отдельной ветке до окончания тестирования Отключить на этапе стабилизации, во время регрессионного тестирования  Cоздание Решение о создании feature toggle принимается на основе различных критериев:\n Изолированность изменений, насколько легко их отключить Риск привнести нестабильность  Реализация  По умолчанию непротестированная логика должна быть отключена Отключать необходимо самым дешевым и надежным способом, с минимальным влиянием на логику Важно не сломать существующую логику, с отключенным feature toggle, т.к. это уже нельзя отключить  Отделение точки принятия решения от логики Feature toggle - это детали реализации, подверженные изменениям. При принятии решений в логике необходимо оперировать подходящим уровнем абстракции.\nОбычно хватает выделения этих знаний в функцию.\nfun shouldUseSessionInParameters() = not(features.sessionInHeader()) Инверсия решений Чтобы убрать из логики знания про реализацию, иногда дешевле переключать всю реализацию целиком:\n@Provides CommonChannelsInteractor provideInteractor(...) { return if (features.webSocketMessengerEnabled()) { MessengerCommonChannelsInteractorImpl(...) } else { ApiCommonChannelsInteractor(...) } } Тестирование Юнит тесты Для того, чтобы выявить все непредвиденные использования переключателей, не задаем никакого состояния по умолчанию. Это вынудит в тесте явно перебрать все состояния.\n@Mock private lateinit var features: Features Компонентные и функциональные тесты В таких тестах нет возможности изоляции логики и по умолчанию используем релизное состояние переключателей. Это компромиссный вариант, в котором делаем акцент на выявлении регрессии, а не на формальной проверке всех возможных состояний. Проверка всех состояний других фич не целесообразна.\nНеобходимы, как минимум, два набора тестов:\n Проверка регресса, старого поведения. Новая фича отключена, все остальные в состоянии по умолчанию. Проверка нового поведения. Новая фича включена, все остальные в состоянии по умолчанию.  Удаление Необходимо обязательно избавляться от устаревших переключателей. Но делать это можно только после того, как убедимся в работоспособности и стабильности решения. Исходя из целей, рекомендуется удалять после feature freeze.\n"});index.add({'id':25,'href':'/avito-android/git/','title':"Git",'content':"Git Слияние веток Для слияния веток используем rebase. Это дает линейную историю и снижает нагрузку на CI. Пара команд может упростить вашу жизнь с rebase: git config rerere.enabled true \u0026ndash; автоматическое разрешение повторяющихся конфликтов при rebase git config pull.rebase true \u0026ndash; rebase при обновлении remote-ветки\nLocal Git hooks ./git_hooks будут синхронизированы с .git/hooks при первом запуске gradle.\nGit LFS Могло быть полезно для хранения некоторых бинарных(или просто объемных) ресурсов в git. Например:\n изображения в документации эталоны скриншотов для тестов дизайн системы json для стабов в компонентных тестах  Не используем в проекте по ряду причин:\n нужно всем устанавливать git lfs локально, чтобы не коммитились ломающие изменения если ошибемся - переписывать историю нужно писать сервер-сайд хук, контролирующий чтобы не попадали изменения без lfs надеемся что битбакет сервер все делает правильно, а там это не прозрачно, bundled версия git и git lfs премердж наш должен учитывать lfs teamcity mirror репозиторий не работает с lfs, придется отключать похоже, а это оптимизация  "});index.add({'id':26,'href':'/avito-android/contributing/howtostart/','title':"How to start",'content':"How to start Минимальные требования  16Gb RAM Linux/OSX/Windows  1. Установи Java Поддерживаем только Java 8.\n2. Установи Intellij IDEA или Android Studio Поддерживаем последнюю стабильную версию, но обычно работает и beta, и canary.\nДля обновлений рекомендуется JetBrains Toolbox.\nВ одном приложении доступны все IDE.\n3. Проверь проект  Подключи VPN Запусти в корне проекта: ./gradlew help  Должно отработать успешно. Если упадет, прочитай текст ошибки и поправь.\n3. Настрой IDE Обнови Kotlin плагин до последней версии Preferences | Languages \u0026amp; Frameworks | Kotlin\nПодключи необходимые плагины  Editorconfig - для code style  Включи оптимизации в IDE Ускорение IDE\n"});index.add({'id':27,'href':'/avito-android/ide/benchmarking/','title':"IDE Benchmarking",'content':"Бенчмарки IDE Используем Performance testing plugin.\nКак попробовать?  Установи плагин Запусти Help \u0026gt; Diagnostic \u0026gt; Execute Performance Scrip from File\nВыбери готовый сценарий из /benchmarks/ide  Как проверить гипотезу и измерить разницу? Используем в ручном режиме:\n Прогони бенчмарк несколько раз до внесения изменений в проект Сохрани резульататы. Они отобразятся в диалоге после прогона бенчмарка Внеси изменения в проект Прогони бенчмарк несколько раз, сравни результаты.  Что еще?  Плагин умеет записывать YourKit snapshot с детальной информацией о всех вызовах методов.  "});index.add({'id':28,'href':'/avito-android/ide/configurations/','title':"IDE Custom configurations",'content':"Кастомные конфигурации Шарим в проекте кастомные run/debug конфигурации, чтобы все работало \u0026ldquo;из коробки\u0026rdquo;.\nТак гарантируем одинаковые корректные настройки, случайно не сломается.\n  avito: собирает, устанавливает и запускает Авито.\n  avitoInstall: собирает и устанавливает Авито, но не запускает автоматически приложение.\nНужна из-за бага \u0026ldquo;Default activity not found\u0026rdquo;.\n  localCheck: проверка всех этапов компиляции с учетом импакт анализа\n  Как расшарить конфигурацию? Sharing Run/Debug Configurations\n"});index.add({'id':29,'href':'/avito-android/ide/speedup/','title':"IDE Speedup",'content':"Ускорение IDE Чтобы IDE меньше тормозила при работе с проектом, попробуй эти настройки:\nВыдай IDE больше памяти По умолчанию IDE выделяет мало, чтобы суметь запуститься на слабой машине.\nHelp | Edit custom VM Options\n-Xmx4g Слишком много не нужно. Чтобы посмотреть реальное потребление памяти:\nAppearance \u0026amp; Behavior | Appearance | Show memory indicator\nВключи удаленную сборку Mirakle\nОставь только необходимые приложения Подключаем в settings.gradle только часть приложений, чтобы ускорить работу с проектом. Посмотри в gradle.properties флаги sync... и выбери какие нужны.\nПереопределяй в системных настройках (~/.gradle/gradle.properties):\nsyncAvito=false sync... После изменения синхронизируй проект.\nОтключи излишние действия во время синхронизации  Preferences | Experimental | Skip source generation on Gradle sync Preferences | Experimental | Skip download of sources and javadoc on Gradle sync Preferences | Experimental | Gradle | Only sync the active variant  Отключи автоматическую синхронизацию проекта Preferences | Build, Execution, Deployment | Compiler | Sync project with Gradle before building\nПроверь что Gradle и Kotlin не запускают несколько демонов ./gradlew --status Если запущено несколько: https://stackoverflow.com/c/avito/questions/109\nОтключи неиспользуемые плагины  Android APK Support Android Games Android NDK App Links Assistant CVS, hg4idea, Subversion integration Firebase  GitHub Google  Task management Terminal Test recorder, TestNG YAML  Отключи индексацию директорий (Spotlight, Антивирус) При сборке проект генерирует много файлов, что вызывает постоянную переиндексацию.\nOSX\nДобавь в исключения Spotlight: System preferences | Spotlight | Privacy\n Директории с android проектами (обязательно) Android SDK Android Studio ~/.gradle ~/.android ~/.gradle-profiler ~/gradle-profiler ~/.m2 ~/Android StudioX.X ? ~/lldb ?  tip: показать скрытые директории в Finder: Cmd + Shift + .\nСкрой ненужные директории и типы файлов Проект большой и в нем много сгенерированных файлов, что нагружает IDE. Чтобы немного помочь, скрой файлы, которые никогда не нужны:\nPreferences | Editor | File Types | Ignore Files and Folders\nНедостатки:\nПро эти исключения легко забыть, неочевидно, может помешать:\n build - не будут видны BuildConfig файлы, сгенерированные файлы, вообще ничего. .gradle;intermediates;kotlin-classes;caches-jvm; - intermediates файлы сборки, обычно не нужны. apt;kapt;kaptKotlin; не будут видны Dagger файлы.\nОни будут красными в редакторе и автоформатирование может удалять их импорты.  kotlin.use.ultra.light.classes (experimental) A light class is a representation of a Kotlin class as the Java PSI, allowing IntelliJ IDEA's Java support features to work with Kotlin classes.\nCmd + Shift + A - найди Registry, включи флаг kotlin.use.ultra.light.classes.\nОсвободи в ОС больше памяти Посмотри какие приложения потребляют много памяти, не используется ли swap.\nДля Google Chrome есть плагины для авто-остановки старых вкладок: The Great suspender\nВключи режим энергосбережения Отключает инспекции и подсветку синтаксиса\nFile | Power Save Mode\n"});index.add({'id':30,'href':'/avito-android/ide/','title':"Ides",'content':""});index.add({'id':31,'href':'/avito-android/infrastructure/','title':"Infrastructure publication",'content':"Avito Android Infrastructure Open source инфраструктурная часть android проектов Avito.\nСтруктура проекта :android\nНабор расширений над android gradle plugin и над android sdk (TODO разделить на два модуля)\n:bitbucket\nКлиент для публикации деталей проверок на CI в открытый PullRequest на Bitbucket Server.\n:build-checks\nGradle plugin для раннего обнаружения проблем в параметрах сборки\n:build-metrics\nGradle plugin для сбора и отправки метрик сборки (стэк: statsd, graphite, grafana)\n:build-properties\nGradle plugin для доставки параметров окружения в ассеты сборки android проекта\n/ci/docker/android-builder\nDocker образ для сборки самого проекта Avito Android Infrastructure\n:docker\nКлиент для работы с docker\n:enforce-repos\nGradle plugin для настройки используемых репозиториев зависимостей\n:file-storage\nКлиент для in-house сервиса хранения бинарных файлов (пример: для скриншотов и видео в отчетах тестов)\n:git\nОбертка для работы с git в gradle\n:impact, :impact-plugin\nGradle Plugin для поиска задетых изменениями модулей относительно target ветки\nсм. Импакт Анализ\n:instrumentation-impact-analysis, :ui-test-bytecode-analyser\nGradle plugin и вспомогательный модуль для поиска связи изменений найденных при помощи impact-plugin и UI тестов\n:kotlin-config\nGradle plugin для настройки всех kotlin модулей в проектах android-приложениях\n:kotlin-dsl-support\nРасширения, в основном скопированные из kotlin-dsl (но также несколько своих).\nНужны для сохранения API в gradle скриптах, т.к. из-за нестабильности kotlin-dsl мы то пользуемся, то отказываемся от него\n:lint-report\nGradle plugin, который склеивает lint репорты из разных модулей для отображения на одной странице\n:logging\nКастомный логгер для использования внутри gradle worker'ов, т.к. gradle logger не сериализуется и имеет ссылку на project(todo: уже не актуально)\n:okhttp\nРасширения над okhttp, которыми активно пользуемся как в плагинах так и в android приложении\n:robolectric-config\nGradle plugin для настройки всех модулей в проектах android-приложениях, которые используют robolectric\n:room-config\nGradle plugin для настройки всех модулей в проектах android-приложениях, которые используют room\n:runner:client, :runner:service, :runner:shared, :runner:shared-test\nКастомный раннер для instrumentation тестов\n:sentry\nКлиент для отправки ошибок инфраструктуры и тестов в Sentry\n:signer\nGradle Plugin для делегирования подписи apk/bundle inhouse сервису\n:slack\nКлиент для удобной публикации нотификаций в slack\n:statsd\nКлиент для отправки метрик через statsd\n:teamcity\nКлиент для работы с Teacmity: обертка для REST API и service messages\n:test-okhttp\nУтилиты для тестирования при помощи okhttpmockwebserver\n:test-project\nУтилиты для тестирования при помощи Gradle Test Kit\n:time\nAPI для работы со временем в плагинах и android приложении\n:trace-event\nКлиент для работы с trace event format\n Specification Trace-Viewer  :utils\nTODO: разобрать по модулям\nПубликация модулей инфраструктуры Настроены два типа публикации:\n Bintray, которая миррорится в jcenter И публикация в inhouse artifactory для проверки неопубликованной версии в интеграции с проектом  Публикация из Teamcity В проекте настроены две соответствующие конфигурации.\nПубликация в bintray осуществляется вручную\nИспользуется ./publish.sh\nВ Artifactory дается возможность указать версию при публикации\nИспользуется ./publish_local.sh\nGradle ./gradlew publishToBintray\nДолжны быть доступны env:\n BINTRAY_USER BINTRAY_API_KEY  ./gradlew publishToArtifactory\nДолжны быть доступны env:\n ARTIFACTORY_URL ARTIFACTORY_USER ARTIFACTORY_PASSWORD  Версию можно указать с помощью:\nenv PROJECT_VERSION или gradle property projectVersion\n"});index.add({'id':32,'href':'/avito-android/test/manual/','title':"Manual",'content':"Ручное тестирование Обрати внимание на Типы Сборок\nГде взять сборку? QApps\n"});index.add({'id':33,'href':'/avito-android/assemble/minimization/','title':"Minimization",'content':"Минимизация сборки Официальная документация\nВ проекте используется R8 (задача на включение \u0026ldquo;full mode\u0026rdquo;)\nПараметры для сборки задаются в корневом gradle.properties\nВ каких типах сборки включена минимизация: Типы сборки\nStory \u0026ldquo;Защита от ошибок минификации кода\u0026rdquo;\nКонфигурация Общая конфигурация собирается по частям из нескольких источников. Помимо способов описанных в документации, конкретно в нашем проекте используется:\n $ANDROID_HOME/tools/proguard/proguard-android-optimize.txt базовый конфиг \u0026lt;app\u0026gt;/proguard/**/*.pro конфигурации разбитые по папкам-типам-сборки, а затем отдельным файлам зависимостям. Собираются в build.gradle при помощи своей функции proguardFromDir()  Посмотреть результирующий конфиг сейчас негде, есть задача на добавление его в артефакты\nСтатьи по теме  Как перестать бояться Proguard и начать жить  "});index.add({'id':34,'href':'/avito-android/assemble/mirakle/','title':"Mirakle",'content':"Mirakle Это Gradle плагин, который переносит сборку проекта на более мощную машину в дата центре. Компьютер во время сборки не так нагружен, можно продолжать работать с проектом.\nКак работает:\n sequenceDiagram 💻-+Builder: Держи проект (rsync) Note right of Builder: Собираю Builder--💻: Получи что уже готово Builder--💻: Закончил Как настроить в первый раз?  Установи rsync Посмотри какой host прописан в mirakle.py Проверь доступность удаленной машины по ssh (с VPN):\nssh [\u0026lt;username\u0026gt;@]\u0026lt;mirakle host\u0026gt;\nЕсли нет доступа:  Проверь есть ли уже ключ (checking for existing SSH keys) или сгенерируй новый. Нужен ключ без пароля, потому что из mirakle (Gradle) его некуда вводить. Добавь свой публичный ssh ключ - инструкция Запроси в Service Desk доступ по ssh на host android-builder   Включи mirakle: ./mirakle.py --enable\nЕсли локальный пользователь отличается: ./mirakle.py --enable --username \u0026lt;username\u0026gt; Проверь работу, запусти любую задачу: ./gradlew help\nВ логе будут сообщения:  Here's Mirakle ... :uploadToRemote :executeOnRemote :downloadInParallel  Проверь кастомные системные параметры сборки в ~/.gradle/gradle.properties\nОни не переносятся на удаленную машину. Выбираем один из вариантов:  Добавь в аналогичный файл на android-builder Добавь аргументами -Pname=value в Preferences | Build, Execution, Deployment | Compiler | Command-line Options\nNB: про такие настройки легко забыть, по возможности избегай их.    В следующие разы нужно только включать ./mirakle.py --enable\nКак отключить? ./mirakle.py --disable\nЧтобы отключить только для текущей сборки, добавь в аргументы gradle -x mirakle\nПолное удаление настроек: /mirakle.py --wipe\nTroubleshooting  Проверь что vpn подключен Проверь доступность mirakle, подключись по ssh  Known issues Сборка в mirakle идет дольше чем локальная  Копирование проекта на другую машину занимает время. Если собираешь что-то небольшое, то сравни с локальной сборкой. Она может оказаться быстрее. На удаленной машине накопились старые файлы в проекте, rsync их не удалил.\nУдали их: ./clean.py --remote  Запустилось не то, что я запускал Проверь что синхронизация проекта проходит успешно.\n"});index.add({'id':35,'href':'/avito-android/architecture/modules/','title':"Modules",'content':"TBD: http://links.k.avito.ru/cfxFKKAg\n"});index.add({'id':36,'href':'/avito-android/performance/','title':"Performances",'content':""});index.add({'id':37,'href':'/avito-android/assemble/profiling/','title':"Profiling",'content':"Профилирование сборки Чтобы посмотреть подробную информацию о скорости сборке попробуй разные инструменты, выбери наиболее простой.\nBuild Speed window (AS 4+)  Собери проект View \u0026gt; Tool Windows \u0026gt; Build \u0026gt; Build Speed  Gradle build scan https://guides.gradle.org/creating-build-scans/\nЗапусти сборку с аргументом --scan.\nВ конце лога будет ссылка на отчет.\nKnown issues:\n Не приходит первое письмо для активации ссылки:\nнапиши в help@gradle.com, приложи ссылку. This build scan cannot be viewed. A permanent error occurred processing the data.\nСкорее всего уперлись в лимит на размер скана. Нет способа проверить это заранее.\nПопробуй собрать что-то более мелкое. Завышено время исполнения задач (#8630)\nЭто видно по косвенным признакам. На графике задача завершается сразу после завершения другой задачи из этого же модуля.  Avito build trace Чтобы обойти ограничения build scan, собираем свой trace со временем исполнения задач.\nВ CI сборках лежит в артефактах TeamCity.\nКак использовать:\n Запусти сборку с любым из аргументов:\n-Pci=true, --scan, --profile, -Pandroid.enableProfileJson=true. Открой файл outputs/trace/build.trace в chrome://tracing  Known issues:\n Завышено время исполнения задач (см. выше).  Реализация:\nСмотри плагин com.avito.android.build-metrics.\nGradle profiler В режиме профилировщика умеет запускать внешние профилировщики.\nПопробуй разные, тут нет однозначного победителя.\ngradle-profiler --profile async-profiler \\ --project-dir . \\ --warmups 1 \\ --gradle-user-home ~/.gradle-profiler \\ --output-dir profiler \\ help Android Tracer mirror-goog-studio-master-dev/tracer/\nЛегкий профилировщик от Google:\n Показывает исполнение кода из AGP внутри gradle worker Можно разметить аннотациями свой код или указать в конфиге, что логировать  Как использовать:\n Запусти сборку с параметром android.enableProfileJson=true Открой файл build/android-profile в chrome://tracing  Кастомная конфигурация:\n Прочти README, есть неочевидные вещи. (jar файл нельзя переименовывать и т.п.) Выбери профиль, в репозитории есть пара под разные сценарии. Прокинь агент в демон, подходит GRADLE_OPTS:\nexport GRADLE_OPTS=\u0026quot;-javaagent:/path/to/trace_agent.jar=/path/to/deploy.profile\u0026quot; Добавь в jvm args в gradle.properties:\norg.gradle.jvmargs=\u0026quot;-javaagent:/path/to/trace_agent.jar=/path/to/deploy.profile\u0026quot;  Полезно посмотреть в образовательных целях, как пример профилирования с помощью java agent\n"});index.add({'id':38,'href':'/avito-android/cd/qapps/','title':"QApps",'content':"QApps QApps Android\nВнутреннее хранилище сборок для ручного тестирования.\nЗаливаем в него apk по расписанию из develop.\nСм. конфиг uploadToQapps в build.gradle приложений.\nКак залить вручную в QApps с ветки? Локально  Для каждого приложения есть задача qappsUpload\u0026lt;build variant\u0026gt;.\nОна заливает уже собранную apk.\n Собери apk ./gradlew :avito:qappsUploadStaging -Pci=true\nЧтобы было проще найти сборку, укажи комментарий аргументом -PbuildNumber=\u0026quot;my custom build\u0026quot;  Known issues  Для релизной сборки не совсем подходит, т.к. не будет подписана релизным сертификатом. Чтобы отправить с другими versionName, versionCode нужно собрать приложение с этими параметрами.\nДля qapps это только комментарии к бинарнику. Даже если обмануть и залить apk в qapps указав другую версию, содержимое apk от этого не изменится.   Из CI  Запусти конфигурацию fullCheck\nВыбери кастомный запуск, укажи свою ветку.\nKnown issues Длится до 1 часа, запускает все тесты.\nЧтобы ускорить, закомментируй лишние шаги в fullCheck конфиге в build.gradle приложений.\nЗадача на более быстрый способ: MBS-7340\n  "});index.add({'id':39,'href':'/avito-android/cd/release/','title':"Release",'content':"Релиз приложения Android Канал для коммуникации: #regression-android\nDashboard релизов\nПолитика релизов мобильных приложений\nКак сделать фикс Для каждого релиза отводим ветку release/\u0026lt;Номер версии\u0026gt;\n Отводим ветку от релизной Делаем ПР с фиксом в релизную ветку Создаем ветку от текущего develop Делаем ПР с черри-пиком того же коммита в develop  Кто сейчас релиз менеджер? На dashboard'е конкретного релиза есть поле Release manager\n"});index.add({'id':40,'href':'/avito-android/analytics/statsd/','title':"Statsd",'content':"Statsd (Graphite) Realtime-метрики для отслеживания текущего состояния.\nMonitoring - см. презентацию в самом начале.\nСм. использование StatsdEvent.\n"});index.add({'id':41,'href':'/avito-android/tags/','title':"Tags",'content':""});index.add({'id':42,'href':'/avito-android/tech_radar/','title':"Tech_radars",'content':""});index.add({'id':43,'href':'/avito-android/test/support/','title':"Testing support",'content':"Поддержка Если нужна помощь по работе с автотестами на проекте, обращайтесь в slack #android-autotesting\nТакже можно завести баг в проект MBS с компонентами Android, TestFramework\n"});index.add({'id':44,'href':'/avito-android/test/','title':"Tests",'content':""});index.add({'id':45,'href':'/avito-android/assemble/troubleshooting/','title':"Troubleshooting",'content':"Troubleshooting Что делать в случае непонятной ошибки? Ситуация: падает синхронизация проекта или сборка. По ошибке ничего не понятно.\nЧтобы найти причину, проще всего последовательно исключать все возможные.\n Исключи влияние локальных изменений: проверь на свежем develop Проверь что включен VPN Исключи mirakle: ./mirakle.py -d Исключи IDE: проверь из консоли Проверь не переопределено ли что-то подозрительное в ~/.gradle/gradle.properties Убедись что конфигурация проекта проходит успешно: ./gradlew help Посмотри детальную ошибку: `./gradlew \u0026ndash;stacktrace Исключи влияние кеширования: ./gradlew \u0026lt;failed task\u0026gt; --no-build-cache\nОчистить кеш можно командой: ./gradlew cleanBuildCache  Если проблема в IDE В консоли отработало без ошибок, но в IDE падает.\n Проверь версию IDE и Kotlin плагина. Возможно они слишком старые или наоборот, alpha/beta версии. Добавь --stacktrace чтобы увидеть детали ошибки:\nSettings \u0026gt; Build, Execution, Deployment \u0026gt; Compiler \u0026gt; Command-line Options: Проверь что не включен offline mode на вкладке Gradle Возможно ошибка в .iml, .idea/ файлах:  ./clean.py --all или File \u0026gt; Re-Import Gradle project File \u0026gt; Invalidate Caches / Restart   Посмотри логи Help \u0026gt; Show log in Finder  Если причина в Mirakle Возможно из mirakle прилетают некорректные данные. Удали их: ./clean.py -r\nКак искать проблемы с кешированием? TBD\nKnown issues D8: Dex file with version \u0026lsquo;N\u0026rsquo; cannot be used with min sdk level \u0026lsquo;M\u0026rsquo; Dex file with version '38' cannot be used with min sdk level '22'. D8 com.android.builder.dexing.DexArchiveMergerException: Error while merging dex archives Предположительно возникает после изменений в плагинах.\nПомогает ./clean.py -a\n"});index.add({'id':46,'href':'/avito-android/test/troubleshootingui/','title':"Troubleshooting UI Tests",'content':"Troubleshooting Известные баги тестового фреймворка  Jira Filter Автофокус камеры зависает на 22 API (https://issuetracker.google.com/issues/139438163)  Как понять почему упал тест? Teamcity Для начала можно посмотреть в TeamCity, открыв тест можно увидеть краткую выжимку о причинах падения\nЕсть краткая причина падения не информативна - это повод написать нам.\nReport Viewer Используем отчеты в Report Viewer, которые содержат:\n Видео с эмулятора  Только для упавших тестов Только для API 23+. На меньших версиях технологии не позволяют записывать надежно   Скриншоты: до и после каждого шага, во время падения Трейс ошибки: цепочка событий которая привела к ошибке Logcat для упавших тестов HTTP запросы и ответы во время шагов Логи запросов к ресурсам: Resource Manager, AB/test, Integration API, phones Логи действий тестового фреймворка  Report Viewer локально При запуске теста локально, ссылка на Report Viewer тоже формируется и доступна в logcat, ищите по фильтру: rv.k.\nЧто делать если тест flaky? 1. Убедись что тест действительно флакует В первую очередь смотрим статистику\nМожно запустить динамическую конфигурацию, указав тест и несколько прогонов сразу.\nОбратите внимание на все возможности которые есть в приложенном отчете.\nЗапуск также полезно использовать чтобы убедится, что изменения помогли побороться с нестабильным поведением.\n2. Отлаживай в IDE В Android Studio должен из коробки работать debug на конкретном тесте.\nhttps://developer.android.com/studio/debug\n3. Если не удалось найти причину Обратись за помощью\nОбязательно приложи:\n Ссылку на репорт  Будет полезно:\n Логи с ошибками  Где посмотреть статистику по стабильности тестов?  Общая статистика по тестам История нестабильности теста  Обратите внимание на параметры фильтрации.\n"});index.add({'id':47,'href':'/avito-android/test/unittesting/','title':"Unit tests",'content':"Unit tests How to write good tests (mockito)\nAssertions Рекомендуется использовать assertThat() вместо assertEquals() и т.п.\nМотивация Типизация assertEquals(\u0026quot;id\u0026quot;, 1L) - падает только в рантайме assertThat(\u0026quot;id\u0026quot;, 'is'(1L)) - проверка при компиляции\nЧитаемость assert \u0026ldquo;equals 3 x\u0026rdquo; assert \u0026ldquo;x is 3\u0026rdquo; - естественный порядок\nКомбинирование условий either(s).or(not(t)) each(s) И т.п. особенно с кастомными матчерами.\nСообщения об ошибках assertTrue(response.contains(\u0026#34;color\u0026#34;) || response.contains(\u0026#34;colour\u0026#34;)) // java.lang.AssertionError // at org.junit.Assert.fail(Assert.java) // at org.junit.Assert.assertTrue(...) // и т.п., никаких подробностей assertThat(response, anyOf(containsString(\u0026#34;color\u0026#34;),containsString(\u0026#34;colour\u0026#34;))) // java.lang.AssertionError: // Expected: (a string containing \u0026#34;color\u0026#34; or a string containing \u0026#34;colour\u0026#34;) // but: was \u0026#34;...\u0026#34; // Expected :(a string containing \u0026#34;color\u0026#34; or a string containing \u0026#34;colour\u0026#34;) // Actual :\u0026#34;...\u0026#34; Matchers Создание Для создания рекомендуется использвать фабричные методы:\nimport org.hamcrest.Matchers.hasSize assertThat(collection, hasSize(1)) Мотивация: меньше завязываемся на детали реализации, внутренние классы библиотеки.\nВерификация Необходимо проверять корректность использования Mockito. Для этого можно использовать Mockito.validateMockitoUsage() либо MockitoJUnit. Мотивация: нестабильные тесты. Нарушение контракта Mockito не приводит сразу к падению, но может влиять на другие тесты. Из-за параллельного запуска падать будут в произвольных местах.\n"});index.add({'id':48,'href':'/avito-android/assemble/benchmarks/','title':"Бенчмарки сборки",'content':"Бенчмарки сборки Для бенчмарков используем Gradle profiler, где можно описать воспрозводимый сценарий:\n Редактировать java/kotlin файлы, android ресурсы Переключаться между коммитами Проверить на разных версиях Gradle Почистить кеш, сборку Учесть прогрев перед измерениями  How to start  Установи вручную или скриптом: benchmarks/profiler.py --install Опиши свой сценарий. Возьми за основу один из готовых из ci/profiler/benchmarks.scenarios и посмотри какие операции необходимы.  Меняем код и ресурсы в модуле serp-core и собираем avito:\nserp_avito_assemble { tasks = [\u0026#34;:avito:assembleDebug\u0026#34;] apply-abi-change-to = \u0026#34;avito-libs/serp-core/src/main/java/com/avito/android/serp/SerpResult.kt\u0026#34; apply-android-resource-change-to = \u0026#34;avito-libs/serp-core/src/main/res/values/strings.xml\u0026#34; } Сохраняем сценарий в файл.\n Запусти профайлер:  gradle-profiler --benchmark \\  --project-dir . \\  --warmups 2 \\  --iterations 5 \\  --gradle-user-home ~/.gradle-profiler \\  --output-dir benchmarks/output \\  --scenario-file scenarios \\  serp_avito_assemble Все параметры запуска\nЧто измеряем в CI? Измеряем сценарии из ci/profiler/benchmarks.scenarios.\nЗапускаем в develop в конфигурации Profiler build. Собираем только пару раз в день, потому что на каждый коммит не хватает железа.\nDashboard с этими сценариями.\n"});index.add({'id':49,'href':'/avito-android/','title':"Введение",'content':"Android в Avito Как начать работу с проектом\nПоддержка Канал в slack: #android-dev\n"});index.add({'id':50,'href':'/avito-android/test/run/','title':"Введение",'content':"Запуск тестов IDE Обрати внимание на кастомные конфигурации\nRobolectric Просто запускаем стрелками Run напротив имени тестового класса или метода.\nВажно чтобы в настройках запуск был делегирован Gradle:\nPreferences \u0026gt; Build, Exceution, Deployment \u0026gt; Build Tools \u0026gt; Gradle\nAS 3.6\u0026#43;  Build and run using: Gradle Run tests using: Gradle  AS 3.5   Delegate IDE build/run actions to Gradle Run tests using: Gradle Test Runner    Instrumentation Known issues  Не работает запуск конкретного метода в тесте, только всего класса (#127662898)  CI Кастомный запуск\n"});index.add({'id':51,'href':'/avito-android/contributing/docs/','title':"Работа с документацией",'content':"Документация Подходы Каким бы хорошим не был продукт, если у него плохая документация, им мало кто будет пользоваться.\nПростой и понятный язык Текст должен помогать читателю решить задачу. Для этого он должен быть простым и понятным. В этом поможет книга Пиши, сокращай. Посмотри примеры на сайте, сравни сам что понятнее. После знакомства с книгой уже не сможешь развидеть плохие тексты.\nglvrd.ru - автоматический поиск грубых ошибок.\nФормат под задачу Не бывает универсальной документации.\nАдаптируем под уровень знаний читателя и для решаемой проблемы:\n    Только учусь Уже знаком     Практические шаги Tutorial How-to guide   Теоретическое знание Explanation Reference    Tutorial Метафора: обучаем ребенка готовить.\nИменование: \u0026ldquo;Getting started\u0026rdquo;\n Ориентация на обучение. Полезно для новых пользователей. Дает практическое понимание вместо теоретического знания. Показывает скорее как, а не что.  Приводит к конкретной цели через серию шагов:\n Простые и понятные Повторяемые и надежные, всегда работают Дают немедленную обратную связь Минимум теории и объяснений, не грузят лишним  How-to guide Метафора: рецепт приготовления блюда\nИменование:\n \u0026ldquo;Как запустить тест в CI?\u0026rdquo; - 👍 \u0026ldquo;Запуск теста в CI\u0026rdquo; - 👎 \u0026ldquo;Тест в CI\u0026rdquo; - 👎     Ориентация на практический результат: как решить проблему.\n  Ключевое отличие от tutorial: уже знакомы с продуктом.\nМожет адресовать проблему, которую новички могут даже не сформулировать.\n  Не объясняет концепции, может только ссылаться при необходимости.\n  Читатель понимает чего хочет достичь, но не знает как.\n  Шаги не такие надежные и повторяемые, читатель уже знаком с продуктом.\n  Шаги более гибкие\n  Описание не обязано быть полным, только то что нужно для проблемы.\n  Reference Метафора: статья в энциклопедии\n  Ориентация на информацию: описать как устроено, как работает.\n  Отличие от tutorial, how to guide: не фокусируется на решении конкретных проблем, хотя и может приводить примеры использования.\n  Структура продиктована кодом, повторяет его\n  Описывает детали в точности как они работают.\n  Объясняет ситуацию как есть, не уходит в дискуссии, мнения, инструкции. Такие отвлечения мешают понять как работает.\n  Explanation Метафора: дискуссия\nИменование: \u0026ldquo;Тестирование инфраструктуры и CI\u0026rdquo;\n Ориентация на понимание, не решает конкретных практических задач.\nЭто самый свободный формат описания. Описывает концепции, поясняет контекст и историю развития Дает альтернативные подходы и мнения, поясняет мотивацию  Подробнее про форматы: What nobody tells you about documentation\nПримеры  GitLab documentaion styleguide  Содержимое Вся документация состоит из набора markdown файлов.\nИспользуем генератор статических сайтов Hugo (тема - Book).\nДля проверки стиля - markdownlint\nБоковое меню Меню редактируется в docs/content/menu/index.md\nСсылки на документацию Абсолютная ссылка: {{\u0026lt; ref \u0026quot;/Name.md\u0026quot; \u0026gt;}}, где путь относителен директории content/.\nОтносительная ссылка: {{\u0026lt; relref \u0026quot;Name.md\u0026quot; \u0026gt;}}.\nAnchor: {{\u0026lt; ref \u0026quot;/Name.md#header\u0026quot; \u0026gt;}}.\nПодробнее: cross references\nСсылки на внутренние ресурсы Документация публичная, поэтому в ней ней не должно быть прямых ссылок на внутренние сервисы (issue tracker, CI, \u0026hellip;).\nЧтобы не терять эту информацию, используй links.k.avito.ru для редиректа.\nСсылки с кастомным путем должны указывать на что-то неизменяемое.\nПуть изменится, а ссылку уже не подменить.  Чтобы посмотреть статистику по ссылке, добавь к ней +.\nСниппеты Кастомные сниппеты для отображения того, что не поддерживает markdown.\nИх несложно создавать. Напиши, если тебе не хватает какого-то типа контента.\nДиаграммы Для диаграм используем Mermaid, описываем их в текстовом виде:\n Содержимое читается без отрисовки картинки Для редактирования не нужны никакие программы  Live editor\n{{\u0026lt;mermaid\u0026gt;}} stateDiagram [*] --\u0026gt; A A --\u0026gt; B B --\u0026gt; [*] {{\u0026lt;/mermaid\u0026gt;}}   stateDiagram [*] -- A A -- B B -- [*] Подсказки / Алерты {{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! {{\u0026lt; /hint \u0026gt;}} Markdown content\nLorem markdownum insigne. Olympo signis Delphis!  Кнопки {{\u0026lt; button relref=\u0026#34;/\u0026#34; \u0026gt;}}Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;http://repo/CONTRIBUTING.md\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Home  Contribute  Вкладки {{\u0026lt; tabs \u0026#34;Unique ID\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}}  MacOS  MacOS Content  Linux  Linux Content  Windows  Windows Content   Столбцы {{\u0026lt; columns \u0026gt;}} Left Content \u0026lt;---\u0026gt; Right Content {{\u0026lt; /columns \u0026gt;}} Left Content  Right Content   Раскрывающаяся панель {{\u0026lt; expand \u0026#34;Title\u0026#34; \u0026gt;}} Markdown content {{\u0026lt; /expand \u0026gt;}}  Title ↕  Markdown content    Формулы KaTeX\n{{\u0026lt; katex \u0026gt;}} \\overline{a \\lor b} = \\overline{a} \\land \\overline{b} {{\u0026lt; /katex \u0026gt;}}    $$ \\overline{a \\lor b} = \\overline{a} \\land \\overline{b} $$ Картинки Попробуй сначала выразить текстом и диаграммами. Картинки и скриншоты дороже поддерживать в актуальном состоянии.\nЗагружаем картинки в любой публичный image storage.\nНа крайний случай, в репозиторий в docs/static ( Static files ) Для более гибкого отображения картинок используй shortcode\nСписки Нумерованный или ненумерованный Используй нумерованный список только если он описывает последовательность шагов.\n👎\nСистема состоит из следующих компонентов: 1. `Collector` 1. `Publisher`   👍\nЗапусти команды: 1. `cd dir` 1. `./prepare_data.sh` 1. `./publish_results.sh`    Выделение терминов Выделяй символом ` команды, параметры, значения, имена файлов и т.п.:\n Добавь префикс Dagger в импортах перед Component Подключи модуль dagger Введи last в поиск Добавь параметр syncAvito в файл properties.ini  Не надо выделять все названия технологий, компаний и т.п. Это нагружает текст, его труднее читать:\n Для DI используем Dagger 👎  Заголовки  Используем только один заголовок h1 как заголовок страницы. Он не отображается в оглавлении.  How to Как посмотреть локально? Запусти docs/build.sh\nДокументация будет доступна по localhost:1313 и обновляться при редактировании.\nКак обновить hugo?  Обнови версию hugo в Dockerfile Обнови другие файлы  Проверь, что локально установлена такая-же версия: hugo version Сгенерируй новый сайт: hugo new site template Сравни директорию docs со сгенерированным пустым сайтом    Как обновить тему? Скачай новую версию темы и подмени существующие файлы.\nМы кастомизировали тему, проверь что не потеряем эти изменения:\n Удалили примеры (book/exampleSite) и статику для них (book/images/) Удалили js файлы для shortcode (book/static/*.js), потому что они могут весить мегабайты. Загружаем из unpkg.com.  Как проверить изменения инфраструктуры? Если затронул что-то кроме md файлов в content/, то проверь вручную.\nЗапусти локально: docs/build.sh\nЧеклист проверки:\n Страница обновляется при изменении контента Поиск находит страницы, ссылки открываются Работают кастомные shortcode: Отображаются диаграммы (mermaid)  Hugo troubleshooting\nРазвертывание в CI Обновляем документацию на каждый новый коммит в develop.\nСмотри реализацию в gradle plugin com.avito.android.docs\nTask :checkDocs Проверяет на пулл реквесте связанность внутренних ссылок по документации.\nTask :deployDocs Выкладывает обновленную документацию в kubernetes после мерджа пулл-реквестов.\n"});index.add({'id':52,'href':'/avito-android/performance/analytics/','title':"Реалтайм-аналитика",'content':"Замеры перформанса экрана Что умеем замерять Пользовательские метрики  время от тача до начала инициализации экрана (предынициализация) время от тача до окончания отрисовки каждого из потоков данных экрана  Этапы работы экрана  время инициализации экрана (ScreenInitTracker) время DI экрана (ScreenDiInjectTracker) время загрузки данных по сети и с диска (наследники ContentLoadingTracker) время обработки данных, например конвертации сетевых моделей в презентационные (ViewDataPreparingTracker) - не всегда используется, потому что не везде есть время отрисовки (с момента посылки команды на отрисовку до того как соответсвующий Runnable отработал на main thread) длительность инициализации и DI компонентов (сабмодулей)  Отправляем метрики в statsd для realtime-аналитики и clickstream для AB-тестирования и детального анализа.\nПользовательские метрики отражают ожидания пользователя: тапнул по экрану - получил, что хотел.\nЧто нужно знать перед написанием кода  определить тип экрана (с предзагрузкой данных, самостоятельный, субкомпонент) создать абстракцию трекера экрана в соответствии с флоу экрана Типы флоу экранов добавить замеры в код синхронизировать имя вашего экрана (screenName) и замеряемые типы контента с таблицей (согласовать имена с iOS-платформой) проверить на дашборде, что ваши замеры действильно отправляются  Типы замеряемых экранов Самостоятельный экран  Activity без фрагментов Activity с Fragment, если он один на экране Конфигурация в которой есть Activity и несколько фрагментов одновременно на экране (В этом случае фрагменты выступают субкомпонентами)  Cубкомпонент  Fragment, который является одним из нескольких отображаемых фрагментов самостоятельного экрана (публичный профиль, главная, etc) Fragment, который является одним из шагов какого-нибудь флоу (подачи, выставления рейтинга продавцу, etc)  Если вы хотите все шаги какого-нибудь флоу затрекать как самостоятельные экраны, это также валидно. Рассматривать фрагмент как самостоятельный экран, так как и как субкомпонент в этом случае - вопрос предпочтений. Фрагмент, покрытый аналитикой, может и должен уметь выступать как самостоятельным экраном, так и субкомпонентом (элементом экрана).\nЭкран с предзагрузкой данных Когда экран осуществляет сетевые запросы и подготовку данных для отображения на следующем экране. Например, при выставлении рейтинга продавцу, сначала нажимаем на рейтинг, открывается фейковый экран с лоадером. Этот экран запрашивает данные для отображения следующего экрана, который будет известен по итогам запроса. Если авторизация есть - переходим на флоу выставления рейтинга, если нет - на авторизацию. С точки зрения пользователя: нажал на рейтинг, появился лоадер, появился экран выбора объявления, по которому будет выставляться рейтинг. Разумно считать, что этап предварительной подготовки для экрана с выбором объявления является частью флоу рейтинга.\nТипы трекеров  ScreenDiInjectTracker - трекает время инициализации DI и время предынициализации (от тача до начала DI) Время предынициализации трекается автоматически. ScreenInitTracker - время инициализации (создание и подключение презентеров, роутеров, вью) LocalContentLoadingTrackerImpl - загрузка одного из потоков данных из локального хранилища, скажем из префов ServerContentLoadingTrackerImpl - загрузка одного из потоков данных с сервера ViewDataPreparingTracker - подготовка данных для экрана (конвертация сетевых моделей в презентационные, например) ContentDrawingTracker - отрисовка данных. Через handler.post учитываает время, которое текущее изменение простояло в очереди на мейн треде UnknownScreenTracker - трекер для экрана с предзагрузкой данных  Понятия:\n screenName - имя экрана, которое обычно передается на этапе создания DI contentType - название потока данных. page - номер страницы. Обычно используется для экранов с бесконечными списками. Отправляется первые пять страниц (page-001..page-005), остальные отправляются как page-etc. Можно опустить. failure - либо failure либо success. Можно использовать свою константу для фейла. SCREEN - константа, которая используется для того, чтобы ScreenInitTracker и ScreenDiInjectTracker работали по умолчанию в режиме для самостоятельного экрана. NO_TIME - константа, которая используется в аргументах фукнций трекинга некоторых трекеров, когда мы хотим отправить данные в statsd, которые получили с прошлого экрана UnknownScreenTracker SUCCESS - дефолтная константа, которая используется в трекерах, которая обозначает, что в текущем потоке данных все операции прошли успешно. Успешно получили данные с сети, например, потом успешно их отрисовали.  В случае ScreenDiInjectTracker и ScreenInitTracker contentType используется для отличения субкомпонента от компонента. Например для экрана-субкомпонета выбора объявления, по которому будет выставляться рейтинг продавцу это будет select-advert. В случае ContentLoadingTracker-ов, ViewDataPreparingTracker, ContentDrawingTracker используется для обозначения потока данных. Например на главной странице это объявления adverts и шорткаты shortcuts.\nПользовательские метрики отправляются только первый раз при трекинге. Этапы работы экрана отправляются каждый раз при вызове соответствующего метода трекинга.\nПримеры вызовов методов трекеров:\ninterface ContentDrawingTracker : Tracker { fun trackContentDrawingTracker(page: Int? = null, failure: Boolean) } //затрекали успешную отрисовку (например, список объявлений) tracker.trackContentDrawingTracker(failure = false) //затрекали неуспешную отрисовку (например, заглушку с предложением повторить запрос) tracker.trackContentDrawingTracker(failure = true) interface ContentLoadingTracker : Tracker { fun trackContentLoading(page: Int? = null, failure: String, durationMs: Long = NO_TIME) } //затрекали успешную отрисовку 1 страницы (например, списка объявлений) tracker.trackContentLoading(page = 1, failure = SUCCESS) //затрекали неуспешную отрисовку 1 страницы (например, заглушку с предложением повторить запрос) tracker.trackContentLoading(page = 1, failure = FAILURE) Типы флоу экранов Флоу экранов бывают двух типов: стандартный и с предзагрузкой данных.\nСтандартный флоу экранов  Пользователь нажимает на кнопку на экране А Создается экран Б (здесь трекаем инициализацию и DI) Экран Б грузит данные (трекаем загрузку потока данных) Экран Б готовит презентационные данные (трекаем подготовку потока данных) Экран Б отрисовывает презентационные данные (трекаем отрисовку потока данных)  Флоу экранов с предзагрузкой Этот флоу отличаются от стандартных тем, что данные для отображения экран грузит не сам: данные для экрана грузит какой-либо предшествующий экран.\nЭкран Б из примеров - это экран с предзагрузкой [с экрана А].\nВариант 1\n Пользователь нажимает на кнопку на экране А Экран А грузит данные (Создаем UnknownScreenTracker и трекаем время загрузки данных) Создается экран Б (здесь восстанавливаем данные с экрана A через ScreenTransfer) Экран Б готовит презентационные данные Экран Б отрисовывает презентационные данные  Пример: пользователь нажимает кнопку \u0026ldquo;разместить объявление\u0026rdquo;. В зависимости от разных условий, пользователя могут отправить на экран размещенного объявления, на экран оплаты размещений или на экран применения дополнительных услуг.\nВариант 2\n Пользователь нажимает на кнопку на экране А Экран А переходит на экран с крутилкой, где это происходит Создаем UnknownScreenTracker и трекаем время инициализации, DI и загрузки данных Создается экран Б (здесь восстанавливаем данные с экрана A через ScreenTransfer) Экран Б готовит презентационные данные Экран Б отрисовывает презентационные данные  Преимущественно такая логика представлена в iOS-платформе.\nПример с главной страницы  graph TD A(Тап по шорткату. Запоминаем дату тача) --|ждем создания экрана| B(ОС создала экран Serp) B --|пошел метод onCreate. Начинаем трекать DI | C(Dependency Injection) C --|Здесь же начинаем трекать Init| D(Init. Закончили трекать когда подключились к презентеру) D -- E(load shortcuts) E -- G(prepare shortcuts) G -- K(draw shortcuts) D -- F(load serp) F -- H(prepare serp - переводим сетевые модели в презентационные) H -- L(draw serp) Как замерять перформанс самостоятельного экрана или субкомпонента В dagger dependency понадобится:\ninterface SelectAdvertDependencies : ComponentDependencies { ... fun screenTrackerFactory(): ScreenTrackerFactory fun timerFactory(): TimerFactory } Создаем dagger-модуль, который подключаем к компоненту экрана:\n@Module(includes = [Declarations::class]) object SelectAdvertAnalyticsModule { @Provides @PerFragment @JvmStatic fun providesScreenInitTracker( screenTrackerFactory: ScreenTrackerFactory, @ScreenAnalytics screenName: String, @ScreenAnalytics isSubComponent: Boolean, factory: TimerFactory ): ScreenInitTracker { return if (isSubComponent) { screenTrackerFactory.createInitTracker(screenName, factory, CONTENT_TYPE_SELECT_ADVERT) } else { screenTrackerFactory.createInitTracker(screenName, factory) } } @Provides @PerFragment @JvmStatic internal fun providesScreenDiInjectTracker( screenTrackerFactory: ScreenTrackerFactory, @ScreenAnalytics screenName: String, @ScreenAnalytics isSubComponent: Boolean, factory: TimerFactory ): ScreenDiInjectTracker { return if (isSubComponent) { screenTrackerFactory.createDiInjectTracker(screenName, factory, CONTENT_TYPE_SELECT_ADVERT) } else { screenTrackerFactory.createDiInjectTracker(screenName, factory) } } @Provides @PerFragment @JvmStatic fun providesScreenFlowTrackerProvider( screenTrackerFactory: ScreenTrackerFactory, @ScreenAnalytics screenName: String, factory: TimerFactory ): ScreenFlowTrackerProvider { return screenTrackerFactory.createScreenFlowTrackerProvider( screenName, factory ) } @Module internal interface Declarations { @Binds @PerFragment fun bindSelectAdvertTracker(tracker: SelectAdvertTrackerImpl): SelectAdvertTracker } }  isSubComponent: Boolean - если экран может использоваться как отдельный экран и как субкомпонент, этот флаг подскажет, как правильно настроить трекеры для отправки данных screenName - имя самостоятельного экрана, или родительского в случае субкомпонента. Требует согласования с iOS табличка CONTENT_TYPE_SELECT_ADVERT - строковая константа, которая помогает отличить данные текущего субкомпонента в графане от данных родительского экрана. Если константу не передавать как аргумент функции, то трекеры будут работать как для самостоятельного экрана с именем screenName если ваш экран не будет выступать в качестве субкомпонента, то isSubComponent можно не использовать.  Субкомпоненты удобны, когда вам нужно информацию со всех шагов видеть в одном окне в графане.\nОтличия самостоятельных экранов от субкомпонентов:\n У субкомпонента есть родитель - самостоятельный экран, который передает субкомпоненту собственный screen name. Все запросы на загрузку, подготовку и отрисовку буду относиться к screen name, который передал родитель субкомпонент имеет строковую константу content-type, которая прибавляется при отправке метрик инициализации и DI в statsd, чтобы отличать их от основного экрана У субкомпонентов трекается только абсолютное время DI и инициализации  Создаем абстракцию трекера:\nclass HomeTrackerImpl @Inject constructor( private val flowTrackerProvider: ScreenFlowTrackerProvider private val diInjectTracker: ScreenDiInjectTracker private val initTracker: ScreenInitTracker factory: TimerFactory ) : HomeTracker { private var locationFromSaveLoadTracker: ContentLoadingTracker? = null private var locationLoadTracker: ContentLoadingTracker? = null private var advertsLoadTracker: ContentLoadingTracker? = null private var advertsPrepareTracker: ViewDataPreparingTracker? = null private var advertsDrawingTracker: ContentDrawingTracker? = null private var shortcutsLoadTracker: ContentLoadingTracker? = null private var shortcutsPrepareTracker: ViewDataPreparingTracker? = null private var shortcutsDrawingTracker: ContentDrawingTracker? = null override fun trackDiInject(durationMs: Long) { diInjectTracker.track(durationMs) } override fun startInit() { initTracker.start() } override fun trackInit() { initTracker.trackInit() } override fun startLoadingLocation() { locationFromSaveLoadTracker = flowTrackerProvider.getContentLoadingFromLocalStorage(CONTENT_LOAD_LOCATION_FROM_SAVE).apply { start() } } override fun trackLocationLoadedFromSave(locationIdForLoad: String?) { locationFromSaveLoadTracker?.trackContentLoading(null, SUCCESS) locationFromSaveLoadTracker = null locationLoadTracker = if (locationIdForLoad != null) { flowTrackerProvider.getContentLoadingFromRemoteStorage(CONTENT_LOAD_LOCATION) } else { flowTrackerProvider.getContentLoadingFromLocalStorage(CONTENT_LOAD_LOCATION) }.apply { start() } } override fun trackLocationLoaded() { locationLoadTracker?.trackContentLoading(null, SUCCESS) locationLoadTracker = null } override fun trackLocationLoadError() { locationLoadTracker?.trackContentLoading(null, FAILURE) locationLoadTracker = null locationFromSaveLoadTracker?.trackContentLoading(null, FAILURE) locationFromSaveLoadTracker = null } override fun startLoadingAdverts() { advertsLoadTracker = flowTrackerProvider.getContentLoadingFromRemoteStorage(CONTENT_TYPE_ADVERT_ITEMS) .apply { start() } } override fun trackAdvertsLoaded(page: Int) { trackAdvertsLoaded(page, SUCCESS) } override fun trackAdvertsPrepare(page: Int) { trackAdvertsPrepare(page, false) } override fun startAdvertsDraw() { startAdvertsDrawingTracker() } override fun trackAdvertsDraw(page: Int) { trackAdvertsDraw(page, false) } override fun trackAdvertsLoadError(page: Int) { trackAdvertsLoaded(page, FAILURE) } override fun trackAdvertsErrorPrepare(page: Int) { trackAdvertsPrepare(page, true) } override fun trackAdvertsErrorDraw(page: Int) { trackAdvertsDraw(page, true) } private fun trackAdvertsLoaded(page: Int, result: String) { advertsLoadTracker?.trackContentLoading(page, result) advertsLoadTracker = null advertsPrepareTracker = flowTrackerProvider.getViewPreparing(CONTENT_TYPE_ADVERT_ITEMS).apply { start() } } private fun trackAdvertsPrepare(page: Int, failure: Boolean) { advertsPrepareTracker?.trackViewDataPreparing(page, failure) advertsPrepareTracker = null } private fun startAdvertsDrawingTracker() { advertsDrawingTracker = flowTrackerProvider.getContentDrawing(CONTENT_TYPE_ADVERT_ITEMS).apply { start() } } private fun trackAdvertsDraw(page: Int, failure: Boolean) { advertsDrawingTracker?.trackContentDrawingTracker(page, failure) advertsDrawingTracker = null } override fun startLoadingShortcuts(local: Boolean) { shortcutsLoadTracker = if (local) { flowTrackerProvider.getContentLoadingFromLocalStorage(CONTENT_TYPE_SHORTCUTS) } else { flowTrackerProvider.getContentLoadingFromRemoteStorage(CONTENT_TYPE_SHORTCUTS) }.apply { start() } } override fun trackShortcutsLoaded() { shortcutsLoadTracker?.trackContentLoading(null, SUCCESS) shortcutsLoadTracker = null } override fun startShortcutsPrepare() { shortcutsPrepareTracker = flowTrackerProvider.getViewPreparing(CONTENT_TYPE_SHORTCUTS).apply { start() } } override fun trackShortcutsPrepare() { shortcutsPrepareTracker?.trackViewDataPreparing(null, false) shortcutsPrepareTracker = null shortcutsDrawingTracker = flowTrackerProvider.getContentDrawing(CONTENT_TYPE_SHORTCUTS).apply { start() } } override fun trackShortcutsDraw() { shortcutsDrawingTracker?.trackContentDrawingTracker(null, false) shortcutsDrawingTracker = null } override fun stopShortcutsLoad() { shortcutsPrepareTracker = null } override fun trackShortcutsLoadError() { shortcutsLoadTracker?.trackContentLoading(null, FAILURE) shortcutsLoadTracker = null } override fun startReloadSession() { stopAllSessions() } override fun startLoadMoreSession() { stopAllSessions() } override fun stopLoadAdvertSession() { stopAllSessions() } Как выглядит трекер с предзагрузкой interface UnknownScreenTracker { fun trackInit(durationMs: Long) fun trackDiInject(durationMs: Long) fun startLoading() fun trackLoading() fun toScreenTransfer(): ScreenTransfer } Вариант 1. Необходимо затрекать только loading, потому что экран в целом отдельный и только запрос относится к целевому экрану.\nВариант 2. Необходимо затрекать init, di, loading, потому что экран целиком занимается тем, что выясняет, какой экран будет следующим.\nМетод toScreenTransfer отдает нам объект, хранящий все необходимые данные для передачи целевому экрану:\nclass ScreenTransfer( val initTime: Long, val loadingTime: Long, val diTime: Long ): Parcelable Этот объект необходимо положить в интент для целевого экрана с помощью BaseActivity.saturateIntentWithTrackingInfo\noverride fun followDeepLink(deepLink: DeepLink) { deepLinkIntentFactory.getIntent(deepLink) ?.let { startActivity(saturateIntentWithTrackingInfo(it, tracker.toScreenTransfer())) } } В целевом экране необходимо затрекать эти данные в onCreate:\nif (savedInstanceState == null) { val screenTransfer = rescueScreenTransfer() screenTransfer?.let { tracker.recover(it) } } Код трекера\nclass RatingPublishTrackerImpl @Inject constructor( ... private val recovery: ScreenTransferRecovery ) : RatingPublishTracker { override fun recover(transfer: ScreenTransfer) { recovery.recover(transfer, RATING_PUBLISH_NAME, CONTENT_TYPE_PRELOAD) } CONTENT_TYPE_PRELOAD - константа, которая позволяет правильно затрекать поток данных который был получен на предыдущем экране.\nRATING_PUBLISH_NAME - имя текущего экрана\nВ даггер модуль добавить:\n@Scope: PerActivity, PerFragment @Binds fun bindScreenTransferRecovery(recovery: ScreenTransferRecovery.Impl): ScreenTransferRecovery Как во время разработки проверить, что замеры отправляются Можно смотреть лог, в нем будут подобные строчки:\nTIME:android-debug.355.os.29.screen-performance.absolute.SearchResults.-.content-loading-server.advertisements.page-001.Wi-Fi.-.success:992\n android-debug - дебажная версия приложения, в релизной - android 355 - version code 29 - версия ОС SearchResults - screenName, имя экрана content-loading-server - загрузка данных с сервера advertisements - contentType, поток данных - объявления success - запрос закончился успешно 992 - количество миллиисекунд, которые длился запрос  Чтобы посмотреть отсылаемые в графану значения, нужно\n зайти на дашборд В Screen name выбрать имя вашего экрана В Release/debug выбрать android-debug для debug-сборки, и android - для релизной Должны появиться значения на дашбордах  Данные в дашборде отображаются с 30-секундной задержкой через сервис агрегации метрик statsd.\nПример в графане Пример с экрана RatingPublish\nВ панели Steps можно увидеть:\n preinit - время от тача по кнопке оставить рейтинг до начала DI экрана с флоу проставления рейтинга. Этот этап включает промежуточный шаг, когда пользователь видел лоадер preload init - этап инициализации экрана RatingPublish di-inject - этап DI экрана RatingPublish load preload - Промежуточный этап, когда пользователь видел лоадер preload. Затрекали с помощью UnknownScreenTracker draw preload - отрисовка данных полученных с прошлого экрана load adverts-list - этап загрузки с сервера списка объявлений на субкомпоненте-фрагменте select-advert (выбор объявления, по которому будет проставляться рейтинг, первый шаг на флоу проставления рейтинга) load next-step - этап загрузки с сервера следующего этапа экрана RatingPublish draw next-step, draw adverts-list - время отрисовки. Не стал отдельно трекать подготовку, ее здесь нет. Если бы залогировал, был бы еще этап подготовки: parse next-step, parse adverts-list component init select-advert - этап инициализации субкомпонента select-advert component di preload, component init preload - затрекали как субкомпонент время инициализации и DI с прошлого экрана component di select-advert - этап DI субкомпонента select-advert  "});index.add({'id':53,'href':'/avito-android/ci/containers/','title':"Сборки в контейнерах",'content':"Сборки в контейнерах Avito Docker documentation\nВсе образы расположены в ci/docker.\nAndroid SDK Базовый образ c build tools. (будет сделан в MBS-7071)\nAndroid builder Образ который умеет собирать приложение в CI.\nКак обновить android-builder?  Собери образ локально для проверки изменений:  cd ci/docker ./publish \u0026lt;папка с dockerfile\u0026gt;` В output будет новый tag образа.\n  Обнови тег образа в _main.sh в переменной IMAGE_ANDROID_BUILDER\n  Убедись что образ отрабатывает корректно при локальном использовании.\nПрогони хотя-бы ci/local_check.sh.\n  Собери образ на ветке в teamcity конфигурации Build android-builder\nВ этом проекте зашита авторизация для доступа к registry.\n  Обнови тег в _main.sh\n  Запушь изменение в ветку.\n  Docker in docker Утилитарный образ, который необходим для запуска и настройки эмулятора.\nКак обновить образ? Build docker-in-docker\nAndroid emulator Эмуляторы имеют кастомные настройки, оптимизированы для стабильности и производительности.\n Небольшое разрешение экрана: 320x480, 4 inch Отключены многие фичи  Как запустить эмулятор? OSX/Windows  CI эмулятор невозможно запустить из-за ограничений виртуализации haxm #51. Поэтому воспроизводим идентичную конфигурацию.\n Создай эмулятор в Android Studio: WVGA (Nexus One) с размером экрана 3.4\u0026rsquo;\u0026rsquo; и разрешением 480x800. Запусти эмулятор Настрой параметры:  adb root adb shell \u0026#34;settings put global window_animation_scale 0.0\u0026#34; adb shell \u0026#34;settings put global transition_animation_scale 0.0\u0026#34; adb shell \u0026#34;settings put global animator_duration_scale 0.0\u0026#34; adb shell \u0026#34;settings put secure spell_checker_enabled 0\u0026#34; adb shell \u0026#34;settings put secure show_ime_with_hard_keyboard 1\u0026#34; adb shell \u0026#34;settings put system screen_off_timeout 1800000\u0026#34; adb shell \u0026#34;settings put secure long_press_timeout 1500\u0026#34;  Перезагрузи эмулятор  См. все настройки в android-emulator/hardware и android-emulator/prepare_snapshot.sh\nЗадача на автоматизацию\n Linux  Проще и надежнее использовать оригинальные CI эмуляторы.\nТребования:\n  Docker\n  KVM\n  Найди актуальную версию образа в Emulator.kt.\n  Разреши подключение к Xorg серверу с любого хоста (изнутри контейнера в нашем случае):\n  xhost +  Запусти эмулятор:  docker run -d \\  -p 5555:5555 \\  -p 5554:5554 \\  -e \u0026#34;SNAPSHOT_DISABLED\u0026#34;=\u0026#34;true\u0026#34; -e \u0026#34;WINDOW\u0026#34;=\u0026#34;true\u0026#34; --volume=\u0026#34;/tmp/.X11-unix:/tmp/.X11-unix:rw\u0026#34; \\  --privileged \\  \u0026lt;registry\u0026gt;/android/emulator-27:\u0026lt;TAG\u0026gt; Или в headless режиме:\ndocker run -d \\  -p 5555:5555 \\  -p 5554:5554 \\  --privileged \\  \u0026lt;registry\u0026gt;/android/emulator-27:\u0026lt;TAG\u0026gt;  Подключись к эмулятору в adb  adb connect localhost:5555    Как обновить образ? Для эмулятора нужна более сложная подготовка, поэтому используем отдельные скрипты и образы.\nCI   Собери образ на ветке в teamcity конфигурации Build android-emulator.\nТеги новых образов будут в файле в артефактах сборки. Обнови теги в Devices.kt Запушь изменение в ветку.   Local  Требования:\n Linux, docker KVM K8S права на push образов в registry-mobile-apps (env переменные DOCKER_LOGIN, DOCKER_PASSWORD)   Запусти скрипт:  cd ci/docker ./publish_emulator android-emulator Соберет образ, протестирует и запушит в docker registry.\n Найти новые теги образов. См. stdout скрипта или файл android-emulator/images.txt Обнови теги образов в _main.sh    Как проверить регрессию?  Прогони instrumentation dynamic чтобы выявить возможную утечку памяти.\nДля этого запусти компонентный тест с большим числом повторов. Прогони fullCheck\nСравни количество тестов по всем статусам, не стало ли больше упавших или потерянных.  Как проверить сколько ресурсов тратит эмулятор? Локально используем cAdvisor\nsudo docker run \\  --volume=/:/rootfs:ro \\  --volume=/var/run:/var/run:ro \\  --volume=/sys:/sys:ro \\  --volume=/var/lib/docker/:/var/lib/docker:ro \\  --volume=/dev/disk/:/dev/disk:ro \\  --publish=8080:8080 \\  --detach=true \\  --name=cadvisor \\  google/cadvisor:latest В CI смотрим в метрики куба.\nBest practices Reproducible image Хотим получать одинаковый образ на любой машине, в любом окружении. Это упрощает отладку проблем и делает сборку более надежной.\nreproducible-builds.org\nИсточники нестабильности:\n Не указана явно версия зависимости. Копируем в образ файлы, сгенерированные вне докера.\nГлядя на такие файлы трудно сказать в каком окружении они созданы, какое содержание ожидаемое.  "});index.add({'id':54,'href':'/avito-android/externallibrarychangeprocess/','title':"Соглашения по работе с внешними библиотеками",'content':"Соглашения по работе с внешними библиотеками Описание устарело.\nНужно пересмотреть и перенести на страницу про работу с зависимостями.    Не нужно использовать без необходимости внешние библиотеки - ради абзаца кода нет смысла утяжелять проект\n  Не стоит использовать библиотеки сомнительного качества:\n С низким рейтингом Плохо покрытые тестами Давно не обновляемые Код в которых заведомо низкого качества и т.п.    Наличие или отсутствие каких-либо из этих свойств не является определяющим при выборе библиотеки. Необходимо руководствоваться требованиями разумности и здравого смысла.\n Перед внедрением библиотеки обсуди с коллегами целесообразность. Обрати внимание на качество библиотеки и ее аналогов: завязка на некачественную библиотеку может стать дорогой в поддержке.  Best practices Хотим использовать актуальные версии зависимостей.\nВыделили ряд соглашений, чтобы не сломать релиз и упростить обновления:\n Не обновлять много зависимостей в одном ПР. Так повышается скорость локализации некорректно работающей библиотеки в случае обнаружения проблем с приложением. Исключения - семейства сильно связанных библиотек: RxJava и т.п. Обновлять версию библиотеки желательно в начале-середине цикла разработки, а не перед стабилизацией/подготовке к регрессу Не использовать нестабильные версии библиотек (snapshot и тп) Обновлять легкие библиотеки или библиотеки, некорректная работа которых будет заметна сразу (dagger2) рекомендуется на версию, которая является набором багфиксов Не рекомендуется обновлять легкую библиотеку на релиз, в котором есть фичи - это источник потенциально нестабильного кода. Упрощая - библиотеки, версия которых заканчивается на 0 (1.2.0) не стоит интегрировать без определенной надобности - лучше подождать начала следующего цикла разработки Тяжелые библиотеки (Google Play Services, Support Library) нельзя обновлять перед регрессом/стабилизацией. Исключения возможны только в случае, если в версии библиотеки вносятся фиксы, которые решают проблемы текущей подготавливаемой версии. Но и в этом случае не рекомендуется ставить версию библиотеки, которая не является набором багфиксов. Такие библиотеки в конце цикла разработки могут версионироваться только по консенсусному согласию с коллегами о необходимости интеграции конкретной версии  "});index.add({'id':55,'href':'/avito-android/test/testframework/','title':"Тестовый фреймворк",'content':"Тестовый фреймворк PageObject PageObject - Martin Fowler\nInteraction Context TODO: move to advanced section\nВнутреннее состояние PO. Используем чтобы отразить иерархию View, унаследовать проверки.\nViewElement PageObject над View. Составляющие:\n InteractionContext - знания про родительский элемент, окружение Actions - действия с элементом Checks - проверки состояния  Создание Для создания используем фабричную функцию element:\nval submitButton: ViewElement = element(withId(R.id.submit_button)) ViewMatcher будет учитывать родительский PageObject, унаследует его matcher.\nВложенные ViewElement Все PageObject могут быть вложенными, отражать реальную иерархию:\n// parent -\u0026gt; container -\u0026gt; button  val container: ViewElement = element(withId(R.id.container)) val button: ViewElement = container.element(withId(R.id.button)) Кастомный ViewElement Для переиспользования Бывает удобно отразить вложенность отдельным классом, чтобы переиспользовать в разных экранах.\n// parent --\u0026gt; selector --\u0026gt; hint  val selector: ImageSelectorElement = element(withId(R.id.selector)) class ImageSelectorElement(interactionContext: InteractionContext) : ViewElement(interactionContext) { val hint: ViewElement = element(withId(R.id.hint)) } Для кастомных actions, checks Еще одна причина для кастомного ViewElement - переопределить кастомные actions, checks. Примеры: RatingBarElement, BottomSheetElement.\nДля дефолтного Matcher Для переиспользуемых компонентов удобно держать внутри знания про дефолтный матчер.\nПри создании элемента будем только дополнять его, но не заменять.\nПока что не умеем модифицировать уже созданный interaction context, поэтому перехватываем при создании элемента:\nclass ElementWithEmbeddedMatcher : HandleParentContext, ViewElement { constructor(interactionContext: InteractionContext) : super(interactionContext.provideChildContext(defaultMatcher())) constructor(interactionContext: InteractionContext, matcher: Matcher\u0026lt;View\u0026gt;) : super(interactionContext.provideChildContext(Matchers.allOf( defaultMatcher(), matcher ))) } HandleParentContext - маркерный интерфейс. Изменяет поведение функции PageObject.element(matcher). Мы сами создаем дочерний контекст, потому что только мы знаем про дефолтный матчер.\nScreen Это PageObject для экрана (activity, fragment, dialog, \u0026hellip;)\nclass PublicProfileScreen : PageObject(), Screen { ... } rootId Явно связываем PageObject с конкретным layout:\noverride val rootId: Int = com.avito.android.public_profile_stuff.R.id.public_profile_screen_root  Помогает быстрее найти какой PageObject для этого экрана и в обратную сторону Все дочерние элементы в PageObject неявно проверяем на вхождение в этот layout Связывает экран с gradle-модулем. Это нужно для работы импакт-анализа  Элементы PageObject содержит вложенные элементы:\nval submitButton: ViewElement = element(withId(R.id.submit_button)) Используем фабричный метод element, чтобы создать вложенный элемент. При каждом действии или проверке автоматически проверяем какой экран сейчас отображается.\nScreenChecks Каждый экран умеет проверять, открыт он сейчас или нет.\nПроверить можно вручную:\nassertion(\u0026#34;\u0026#34;\u0026#34;Перешли на экран ...\u0026#34;\u0026#34;\u0026#34;) { Screen.vasPublish.checks.isOpened() } Недостатки очевидны:\n Добавляем проверки вручную, зачастую уже после того как столкнемся с ошибкой Проверки надо поддерживать Это шум. Если я обращаюсь к элементу экрана, то ожидаю что экран должен быть сейчас виден.  Мы умеем автоматически проверять какой экран открыт перед любым действием или проверкой.\nДля этого необходимо подготовить экран:\n Проверить что экран наследуется от PageObject Проверить что экран использует автоматическую проверку  override val checks: ScreenChecks = StrictScreenChecks(this) Включим это по умолчанию в MBS-7204\n Создавать вложенные элементы с помощью фабричной функции element:  val submitButton: ViewElement = element(withId(R.id.submit_button)) // 👍 val submitButton = ViewElement(withId(R.id.submit_button)) // 👎 Legacy Так мы связываем вложенный элемент с экраном и используем это уже во всех его действиях:\nsubmitButton.checks.displayedWithText(\u0026#34;Отправить\u0026#34;) // \u0026lt;-- здесь неявно проверим что текущий экран открыт Параметризация экрана Часто бывает что один и тот-же экран умеет показывать разные данные, загруженные из API.\nУдобно знать про эти состояния и учитывать в проверках:\nfun Screen.publishParamsWithTitle(title: String) = PublishParamsScreen(title) class PublishParamsScreen(val title: String? = null) : PageObject(), Screen { ... if (title != null) { title.checks.withText(title) } ... } How to test Network TBD\nAnalytics Проверяем что событие доставлено до транспорта (Analytics) с нужными параметрами.\nНе нужно тестировать сам транспорт.\n@get:Rule val analytics = AnalyticsRule() @Test fun screen_shown___ShowSearchMapEvent_should_be_sent() { screenRule.start() Screen.mapScreen.checks.isOpened() analytics.checks.assertEventTracked\u0026lt;ShowSearchMapEvent\u0026gt;() } "});index.add({'id':56,'href':'/avito-android/tech_radar/techradar/','title':"Тех радар",'content':"Tech radar Это список технологий и практик, по каждой из которой описано:\n Статус и рекомендации по использованию Накопленные знания, ограничения, причины почему выбрали или отказались  Оригинал: https://www.thoughtworks.com/radar\nFAQ Какие вопросы помогает решить тех радар?  По каким критериям выбрана технология Х? Что именно должно измениться, чтобы мы пересмотрели выбор этой технологии? Хочу затащить Х, как мне проверить и сравнить с Y, по каким критериям? Помню что пробовали Х, почему отказались? Как пойму что можно пересмотреть?  Нужно проводить через радар все технологии? Нет, только дорогие, которые влиюят на весь проект и не сможем заменить за адекватное время.\nРекомендации тех радара являются обязательными? Мы верим в то, что коллективные решения и взвешенные компромиссы работают лучше. Но взгляды людей и команд могут не совпадать. Поэтому хотим чтобы процесс помогал сгладить конфликты.\nНикому не хочется работать в проекте с зоопарком разных подходов и легаси технологий и зависимостей, которые затащили ради интереса и перестали поддерживать.\nВ радаре есть статусы, к которым предъявляем разные требования.\nСначала пробуем технологию с меньшими рисками, взвешенно внедряем дальше или отказываемся.\nМожно думать о радаре как о способе синхронизации.\nПочему не используем тех радар компании?  Удобно же смотреть все технологии компании на одном радаре. Зачем отдельно?\n Причины теже, почему не нравится Confluence.\nЧтобы документация работала и не протухала, ее нужно максимально встроить в ежедневную работу.\nОтдельный репозиторий усложняет: про него надо помнить, отдельно подписываться на изменения, делать отдельный PR.\nЧем проще, тем выше шанс что это будет работать.\nТехнологии и практики Напиши в #android-dev что именно тебе хотелось бы здесь видеть.\n"});index.add({'id':57,'href':'/avito-android/values/','title':"Ценности",'content':"Ценности Какие принципы ценим  KISS DRY YAGNI SOLID  Какие качества кода принимаем во внимание  Тестируемость Поддерживаемость  Простота Читаемость Гибкость Расширяемость (OCP)    Ресурсы  Clean Code by Robert C. Martin Effective Java by Joshua Bloch  "});})();